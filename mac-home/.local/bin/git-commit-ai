#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'USAGE'
Usage: git-commit-ai [options] [-- <git commit args>]

生成提交信息（基于 Git 仓库）并可选直接 `git commit`。

Options:
  --model NAME         指定 AI 模型（默认：$GIT_COMMIT_AI_MODEL 或 gpt-5）
  --max-bytes N        发送给模型的 diff 最大字节数（默认：$GIT_COMMIT_AI_MAX_BYTES 或 120000）
  --preview            仅打印生成结果，不提交
  --commit             直接提交（不再询问）
  --yes                等同 --commit
  --show-prompt        打印发送给模型的完整提示词
  --extra TEXT         追加一段实时指令到提示词
  --lang CODE          指定输出语言，如 zh、en（默认：zh）
  --chinese            快捷方式，等同 --lang zh
  --wrap-subject STYLE 自定义标题包装（例如 brackets、cn-brackets；默认：cn-brackets）
  --bracket-title      标题使用半角方括号 []
  --bracket-title-cn   标题使用全角方括号 【】
  --reasoning-effort, -r V 设置 Codex 推理强度（默认读取配置，可选：minimal/low/medium/high）
  --api NAME           指定使用的 API 后端 (默认: codex，可选: gemini)
  -h, --help           查看帮助

环境变量：
  GEMINI_API_KEY            使用 gemini 后端时的 API Key
  GIT_COMMIT_AI_BACKEND      默认的 API 后端（默认 codex，可选 gemini）
  GIT_COMMIT_AI_MODEL        默认模型名称
  GIT_COMMIT_AI_MAX_BYTES    diff 上限
  GIT_COMMIT_AI_EXTRA_PROMPT 额外固定提示词
  GIT_COMMIT_AI_COMMAND      调用命令（默认：codex）
  GIT_COMMIT_AI_CLI_ARGS     额外传给 Codex CLI 的参数（以空格分隔）
  GIT_COMMIT_AI_LANG         默认输出语言（如 zh、en；默认 zh）
  GIT_COMMIT_AI_WRAP_SUBJECT 默认标题包装样式（默认 cn-brackets）
  GIT_COMMIT_AI_DEBUG        非空时打印调试信息
  GIT_COMMIT_AI_KEEP_HISTORY 非空时保留 Codex CLI 历史目录（默认使用隔离目录）
  GIT_COMMIT_AI_CODEX_HOME   自定义隔离目录根路径（默认：$HOME/.codex/git-commit-ai）
USAGE
}

MODEL=${GIT_COMMIT_AI_MODEL:-gpt-5}
MAX_BYTES=${GIT_COMMIT_AI_MAX_BYTES:-120000}
EXTRA_PROMPT=${GIT_COMMIT_AI_EXTRA_PROMPT:-}
CLI_COMMAND=${GIT_COMMIT_AI_COMMAND:-codex}
# 兼容误设别名：若显式设为 "dx"，视为 codex
if [[ "$CLI_COMMAND" == "dx" ]]; then
  CLI_COMMAND="codex"
fi
DEFAULT_CLI_ARGS=""
LANG_PREF=${GIT_COMMIT_AI_LANG:-zh}
SUBJECT_STYLE=${GIT_COMMIT_AI_WRAP_SUBJECT:-cn-brackets}
REASONING_EFFORT=${GIT_COMMIT_AI_REASONING_EFFORT:-}
DEBUG=${GIT_COMMIT_AI_DEBUG:-}
API_BACKEND=${GIT_COMMIT_AI_BACKEND:-codex}

AUTO_COMMIT=0
PREVIEW_ONLY=0
ASSUME_YES=0
SHOW_PROMPT=0
EXTRA_RUNTIME_PROMPT=""
GIT_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --model) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --model 需要参数" >&2; exit 2; }
      MODEL="$2"
      shift 2
      ;;
    --max-bytes) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --max-bytes 需要参数" >&2; exit 2; }
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        echo "git-commit-ai: --max-bytes 必须为整数" >&2
        exit 2
      fi
      MAX_BYTES="$2"
      shift 2
      ;;
    --preview|--dry-run|--message-only) 
      PREVIEW_ONLY=1
      shift
      ;;
    --commit) 
      AUTO_COMMIT=1
      shift
      ;;
    --yes|-y) 
      AUTO_COMMIT=1
      ASSUME_YES=1
      shift
      ;;
    --show-prompt) 
      SHOW_PROMPT=1
      shift
      ;;
    --extra) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --extra 需要参数" >&2; exit 2; }
      EXTRA_RUNTIME_PROMPT="$2"
      shift 2
      ;;
    --api) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --api 需要参数" >&2; exit 2; }
      API_BACKEND="$2"
      shift 2
      ;;
    --lang) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --lang 需要参数" >&2; exit 2; }
      LANG_PREF="$2"
      shift 2
      ;;
    --chinese) 
      LANG_PREF="zh"
      shift
      ;;
    --wrap-subject) 
      [[ $# -ge 2 ]] || { echo "git-commit-ai: --wrap-subject 需要参数" >&2; exit 2; }
      SUBJECT_STYLE="$2"
      shift 2
      ;;
    --bracket-title) 
      SUBJECT_STYLE="brackets"
      shift
      ;;
    --bracket-title-cn) 
      SUBJECT_STYLE="cn-brackets"
      shift
      ;;
    -r|--reason|--reasoning|--reasoning-effort)
      [[ $# -ge 2 ]] || { echo "git-commit-ai: $1 需要参数" >&2; exit 2; }
      REASONING_EFFORT="$2"
      shift 2
      ;;
    -h|--help) 
      show_help
      exit 0
      ;;
    --) 
      shift
      GIT_ARGS=("${@}")
      break
      ;;
    *)
      GIT_ARGS+=("$1")
      shift
      ;;
  esac
done

# 确保在 Git 仓库内
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "git-commit-ai: 当前目录不是 Git 仓库" >&2
  exit 1
fi

# 查找 Codex CLI（仅在使用 codex 后端时）
if [[ "$API_BACKEND" == "codex" ]]; then
  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    if [[ -d "$HOME/.local/share/mise/shims" ]]; then
      PATH="$HOME/.local/share/mise/shims:$PATH"
    fi
  fi

  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    if [[ -x "/opt/homebrew/bin/$CLI_COMMAND" ]]; then
      PATH="/opt/homebrew/bin:$PATH"
    elif [[ -x "/home/linuxbrew/.linuxbrew/bin/$CLI_COMMAND" ]]; then
      PATH="/home/linuxbrew/.linuxbrew/bin:$PATH"
    elif [[ -x "$HOME/.local/bin/$CLI_COMMAND" ]]; then
      PATH="$HOME/.local/bin:$PATH"
    fi
  fi

  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    echo "git-commit-ai: 找不到 $CLI_COMMAND，可设置 GIT_COMMIT_AI_COMMAND 自定义" >&2
    exit 127
  fi
fi

# 仅展示分支信息与“已暂存”的索引变更，过滤未暂存/未跟踪
STATUS_OUTPUT=$(git status --porcelain=v1 --branch 2>/dev/null | grep -E '^(##|[^ ?])' || true)
# 只检查暂存区的改动
DIFF_STAT=$(git diff --cached --stat 2>/dev/null || true)
DIFF_OUTPUT=$(git diff --cached --patch 2>/dev/null || true)

if [[ -z "$DIFF_STAT" && -z "$DIFF_OUTPUT" ]]; then
  echo "git-commit-ai: 没有检测到暂存的改动 (no staged changes)。请先使用 'git add' 命令添加文件。" >&2
  exit 1
fi

TRUNCATED_FLAG=""
if (( MAX_BYTES > 0 )); then
  DIFF_BYTES=$(printf '%s' "$DIFF_OUTPUT" | wc -c | tr -d ' ')
  if (( DIFF_BYTES > MAX_BYTES )); then
    DIFF_OUTPUT=$(printf '%s' "$DIFF_OUTPUT" | head -c "$MAX_BYTES")
    TRUNCATED_FLAG=$'\n\n[Diff truncated to '
    TRUNCATED_FLAG+="$MAX_BYTES"
    TRUNCATED_FLAG+=$' bytes for AI prompt.]'
  fi
fi

BASE_PROMPT_EN=$'You are an expert developer creating high-quality commit messages for Git repositories.\nGuidelines:\n- Provide a concise subject line (<= 72 characters).\n- Make the subject specific and concrete; prefer user-visible behavior or feature area over file/module names. Avoid listing files or internal helper identifiers (unless they are user-facing commands). Avoid vague words like update, improve, fix.\n- Pack as many key points as feasible into the subject using compact separators (/, -, comma), while staying within 72 characters; if not possible, include the top 2–3 most important points.\n- Output only the commit message, with the subject on the first line; no preamble, meta text, disclaimers, or headings; do not write lines like "Here is...", "Drafting...", or "in Chinese".\n- Add at most 3 short bullets after a blank line; each bullet should be a single clause starting with a verb, avoid long chains (and/then/;), <= 80 characters.\n- No Markdown formatting (no bold/italics/headings) and no code fences or surrounding quotes.\n- Prioritise the most impactful changes if the diff is long.\n- Use sentence case for the subject.\n- Example (good): 【Unify source label and keep separators】; Example (bad): 【git-commit-ai/jj-commit-ai】.\n'
BASE_PROMPT="$BASE_PROMPT_EN"

if [[ -n "$LANG_PREF" ]]; then
  case "$LANG_PREF" in
    zh|zh-CN|zh-cn|cn|中文|简体中文) 
      BASE_PROMPT=$'你是一名资深开发者，需要为 Git 仓库撰写高质量的提交信息。\n规范：\n- 提交标题不超过 72 个字符，使用简洁的陈述语气。\n- 标题需具体明确：优先描述“用户可见的行为/影响或功能区域”；除非是用户直接使用的命令名，否则不要把文件/模块名（尤其是 foo/bar 形式）当作标题主体；避免“更新/优化/修复”等过于抽象的词。\n- 标题尽可能涵盖本次修改的多个重点；可用“/、-、、”等紧凑分隔符串联，整体不超过 72 字符；若无法全部容纳，请保留 2–3 个最重要要点。\n- 只输出提交信息本身：首行直接给出标题；不要输出任何引导语/说明/免责声明/小标题；不要出现“以下是…/Here is/草拟/正在用中文”等字样。\n- 标题下方空一行后列出要点；最多 3 条，每条使用动宾短语且只包含一项结果，不要长句或多个“并且/以及”，长度不超过 80 字符。\n- 不要使用 Markdown 强调/标题/代码块（如 **、#、```），也不要在外层加引号。\n- 若改动较多，请突出最重要的影响。\n- 所有内容必须使用简体中文撰写；如模型生成了非中文，请立即用简体中文重新表述。\n- 示例（好的）：【统一来源标签并保留分隔线】；示例（不佳）：【git-commit-ai/jj-commit-ai】。\n'
      ;;
    *) 
      BASE_PROMPT="${BASE_PROMPT_EN}Please write the subject line and bullet list in ${LANG_PREF}.\n"
      ;;
  esac
fi

if [[ -n "$SUBJECT_STYLE" ]]; then
  case "$SUBJECT_STYLE" in
    brackets) 
      if [[ -n "$LANG_PREF" ]]; then
        case "$LANG_PREF" in
          zh|zh-CN|zh-cn|cn|中文|简体中文) 
            BASE_PROMPT+=$'\n请将提交标题整体放在半角方括号内，例如：[新增功能]。\n'
            ;;
          *)
            BASE_PROMPT+=$'\nWrap the subject line in square brackets, e.g. [Subject Title].\n'
            ;;
        esac
      else
        BASE_PROMPT+=$'\nWrap the subject line in square brackets, e.g. [Subject Title].\n'
      fi
      ;;
    cn-brackets) 
      if [[ -n "$LANG_PREF" && $LANG_PREF =~ ^(zh|zh-CN|zh-cn|cn|中文|简体中文)$ ]]; then
        BASE_PROMPT+=$'\n请将提交标题整体放在全角方括号内，例如：【新增功能】。\n'
      else
        BASE_PROMPT+=$'\nWrap the subject line in full-width brackets, e.g. 【Subject Title】.\n'
      fi
      ;;
    *)
      ;;
  esac
fi

if [[ -n "$EXTRA_PROMPT" ]]; then
  BASE_PROMPT+=$'\nAdditional preferences:\n'
  BASE_PROMPT+="$EXTRA_PROMPT"
  BASE_PROMPT+=$'\n'
fi

if [[ -n "$EXTRA_RUNTIME_PROMPT" ]]; then
  BASE_PROMPT+=$'\nReal-time instructions:\n'
  BASE_PROMPT+="$EXTRA_RUNTIME_PROMPT"
  BASE_PROMPT+=$'\n'
fi

PROMPT_BODY=$'\nRepository status (branch + staged index only):\n'
PROMPT_BODY+="$STATUS_OUTPUT"
PROMPT_BODY+=$'\n\nDiff summary (git diff --stat):\n'
PROMPT_BODY+="$DIFF_STAT"
PROMPT_BODY+=$'\n\nDiff (git diff --patch):\n'
PROMPT_BODY+="$DIFF_OUTPUT"
PROMPT_BODY+="$TRUNCATED_FLAG"

FINAL_PROMPT="$BASE_PROMPT$PROMPT_BODY"

if (( SHOW_PROMPT )); then
  echo "===== AI PROMPT BEGIN ====="
  printf '%s\n' "$FINAL_PROMPT"
  echo "===== AI PROMPT END ====="
fi

COMMIT_MESSAGE=""
USING_FALLBACK=0
CLI_STATUS=0
MESSAGE_SOURCE=""

if [[ "$API_BACKEND" == "gemini" ]]; then
    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        echo "git-commit-ai: 使用 gemini 后端时，必须设置 GEMINI_API_KEY 环境变量" >&2
        exit 1
    fi

    set +e
    COMMIT_MESSAGE=$(GIT_COMMIT_AI_PROMPT="$FINAL_PROMPT" \
                     GEMINI_API_KEY="${GEMINI_API_KEY}" \
                     python3 - <<'PY_GEMINI'
import os
import sys
import json
import urllib.request

def main():
    prompt = os.environ.get('GIT_COMMIT_AI_PROMPT')
    api_key = os.environ.get('GEMINI_API_KEY')
    model = os.environ.get('GIT_COMMIT_AI_GEMINI_MODEL', 'gemini-1.5-flash-latest')

    if not prompt:
        print("Error: Prompt is empty.", file=sys.stderr)
        sys.exit(1)
    if not api_key:
        print("Error: GEMINI_API_KEY is not set.", file=sys.stderr)
        sys.exit(1)

    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}"
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": 0.4,
            "topK": 32,
            "topP": 1,
            "maxOutputTokens": 4096,
            "stopSequences": []
        },
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }

    req = urllib.request.Request(url, data=json.dumps(data).encode('utf-8'), headers=headers)
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                response_body = json.loads(response.read().decode('utf-8'))
                candidates = response_body.get('candidates', [])
                if candidates:
                    content = candidates[0].get('content', {})
                    parts = content.get('parts', [])
                    if parts:
                        message = parts[0].get('text', '')
                        def sanitize(msg: str) -> str:
                            lines = []
                            for raw in (msg or "").splitlines():
                                s = raw.strip()
                                if not s:
                                    lines.append("")
                                    continue
                                low = s.lower()
                                meta_kw = ("draft", "drafting", "compose", "composing", "write", "writing", "here is", "in chinese")
                                if ((s.startswith("**") and s.endswith("**")) or s.startswith("#")) and any(k in low for k in ("commit", "message", "提交", "信息", "chinese", "中文")):
                                    continue
                                if any(k in low for k in meta_kw) and ("commit" in low or "message" in low or "提交" in s or "信息" in s):
                                    continue
                                lines.append(s)
                            # trim leading/trailing blanks
                            while lines and not lines[0]:
                                lines.pop(0)
                            while lines and not lines[-1]:
                                lines.pop()
                            if len(lines) > 1 and lines[1] != "":
                                lines.insert(1, "")
                            return "\n".join(lines).strip()
                        print(sanitize(message))
                    else:
                        print(f"Error: Gemini API response is missing 'parts'. Full response: {response_body}", file=sys.stderr)
                        sys.exit(1)
                else:
                    print(f"Error: Gemini API response has no candidates. Full response: {response_body}", file=sys.stderr)
                    sys.exit(1)
            else:
                error_body = response.read().decode('utf-8')
                print(f"Error: Gemini API request failed with status {response.status}: {error_body}", file=sys.stderr)
                sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Error: Failed to reach Gemini API: {e.reason}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
PY_GEMINI
    )
    CLI_STATUS=$?
    set -e
    if (( CLI_STATUS == 0 )); then
      MESSAGE_SOURCE="gemini"
      [[ -z "$COMMIT_MESSAGE" ]] && CLI_STATUS=1
    fi

elif [[ "$API_BACKEND" == "codex" ]]; then
    KEEP_HISTORY=${GIT_COMMIT_AI_KEEP_HISTORY:-}
    SOURCE_CODEX_HOME=${CODEX_HOME:-$HOME/.codex}
    CUSTOM_CODEX_HOME=${GIT_COMMIT_AI_CODEX_HOME:-$SOURCE_CODEX_HOME/git-commit-ai}
    USE_ISOLATED_CODEX_HOME=0

    if [[ -z "$KEEP_HISTORY" && -z "${CODEX_HOME+x}" ]]; then
      USE_ISOLATED_CODEX_HOME=1
      CODEX_ENV_HOME="$CUSTOM_CODEX_HOME"
      mkdir -p "$CODEX_ENV_HOME"
      if [[ -d "$SOURCE_CODEX_HOME" ]]; then
        for file in config.toml auth.json internal_storage.json; do
          if [[ -e "$SOURCE_CODEX_HOME/$file" && ! -e "$CODEX_ENV_HOME/$file" ]]; then
            cp -p "$SOURCE_CODEX_HOME/$file" "$CODEX_ENV_HOME/$file" 2>/dev/null || true
          fi
        done
        if [[ -d "$SOURCE_CODEX_HOME/sessions" && ! -d "$CODEX_ENV_HOME/sessions" ]]; then
          mkdir -p "$CODEX_ENV_HOME/sessions"
          cp -Rp "$SOURCE_CODEX_HOME/sessions/." "$CODEX_ENV_HOME/sessions/" 2>/dev/null || true
        fi
      fi
      rm -f "$CODEX_ENV_HOME/history.jsonl" 2>/dev/null || true
    else
      CODEX_ENV_HOME="$SOURCE_CODEX_HOME"
    fi

    TMP_STDOUT=$(mktemp "${TMPDIR:-/tmp}/git-codex-stdout-XXXXXX")
    TMP_OUTPUT=$(mktemp "${TMPDIR:-/tmp}/git-codex-output-XXXXXX")
    MSG_FILE=""
    cleanup() {
      [[ -n "$TMP_STDOUT" && -f "$TMP_STDOUT" ]] && rm -f "$TMP_STDOUT"
      [[ -n "$TMP_OUTPUT" && -f "$TMP_OUTPUT" ]] && rm -f "$TMP_OUTPUT"
      [[ -n "$MSG_FILE" && -f "$MSG_FILE" ]] && rm -f "$MSG_FILE"
    }
    trap cleanup EXIT

    CLI_ARGS=("$CLI_COMMAND" "exec" "--skip-git-repo-check" "--output-last-message" "$TMP_OUTPUT")
    [[ -n "$MODEL" ]] && CLI_ARGS+=("--model" "$MODEL")
    if [[ -n "$REASONING_EFFORT" ]]; then
      CLI_ARGS+=("-c" "model_reasoning_effort=\"$REASONING_EFFORT\"")
    fi
    CLI_ARGS+=("--json")

    if [[ -n "${GIT_COMMIT_AI_CLI_ARGS:-}" ]]; then
      # shellcheck disable=SC2206
      EXTRA_CLI_ARGS=("${GIT_COMMIT_AI_CLI_ARGS[@]}")
      CLI_ARGS+=("${EXTRA_CLI_ARGS[@]}")
    fi

    [[ -n "$DEBUG" ]] && {
      echo "[git-commit-ai] 调用命令: ${CLI_ARGS[*]}" >&2
      if (( USE_ISOLATED_CODEX_HOME )); then
        echo "[git-commit-ai] 使用隔离 CODEX_HOME: $CODEX_ENV_HOME" >&2
      fi
    }

    set +e
    if (( USE_ISOLATED_CODEX_HOME )); then
      CODEX_HOME="$CODEX_ENV_HOME" "${CLI_ARGS[@]}" "$FINAL_PROMPT" >"$TMP_STDOUT" 2>&1
    else
      "${CLI_ARGS[@]}" "$FINAL_PROMPT" >"$TMP_STDOUT" 2>&1
    fi
    CLI_STATUS=$?
    set -e

    if (( USE_ISOLATED_CODEX_HOME )); then
      rm -f "$CODEX_ENV_HOME/history.jsonl" 2>/dev/null || true
    fi

    if (( CLI_STATUS == 0 )); then
        export RAW_RESPONSE_PATH="$TMP_OUTPUT"
        export RAW_STDOUT_PATH="$TMP_STDOUT"
        COMMIT_MESSAGE=$(python3 - <<'PY'
import json
import os
import re
import sys

ANSI_RE = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
JSON_DECODER = json.JSONDecoder()

def read_text(path: str) -> str:
    if not path or not os.path.exists(path):
        return ""
    with open(path, "r", encoding="utf-8", errors="replace") as fh:
        return fh.read()

def clean(text: str) -> str:
    text = text.replace('\r', '\n')
    text = ANSI_RE.sub('', text)
    cleaned_lines = []
    for raw in text.splitlines():
        stripped = raw.strip()
        if not stripped:
            continue
        if stripped.startswith('{') and stripped.endswith('}'):
            if '"_context_window"' in stripped or '"provider"' in stripped or '"prompt"' in stripped:
                continue
        if stripped.startswith('[') and stripped.endswith(']'):
            continue
        cleaned_lines.append(stripped)
    return "\n".join(cleaned_lines).strip()

def from_struct(obj):
    if isinstance(obj, str):
        return clean(obj)
    if isinstance(obj, dict):
        if 'msg' in obj:
            cand = from_struct(obj['msg'])
            if cand: return cand
        if obj.get("event") in {"info", "log", "status", "debug"}:
            return from_struct(obj.get("data") or obj.get("content") or obj.get("text"))
        if obj.get("role") == "assistant":
            return from_struct(obj.get("content"))
        for key in ("content", "text", "message", "output", "result", "response", "value", "data", "messages"):
            if key in obj:
                val = from_struct(obj[key])
                if val: return val
        return ""
    if isinstance(obj, (list, tuple)):
        for item in obj:
            val = from_struct(item)
            if val: return val
    return ""

def iter_json_stream(text: str):
    idx = 0
    length = len(text)
    while idx < length:
        while idx < length and text[idx].isspace(): idx += 1
        if idx >= length: break
        try:
            obj, end = JSON_DECODER.raw_decode(text, idx)
            yield obj
            idx = end
        except json.JSONDecodeError:
            idx += 1

def parse_json_blob(text: str) -> str:
    try: data = json.loads(text)
    except Exception: data = None
    if data is not None:
        val = from_struct(data)
        if val: return val
    for obj in iter_json_stream(text):
        val = from_struct(obj)
        if val: return val
    return ""

def parse_json_lines(text: str) -> str:
    for line in reversed(text.splitlines()):
        line = line.strip()
        if not line: continue
        try: data = json.loads(line)
        except Exception: continue
        val = from_struct(data)
        if val: return val
    return ""

def strip_meta_blocks(message: str) -> str:
    def is_meta_line(s: str) -> bool:
        low = s.lower().strip()
        if not low:
            return False
        if (s.startswith('**') and s.endswith('**')) or s.startswith('#'):
            if any(k in low for k in ('commit', 'message', '提交', '信息', 'chinese', '中文')):
                return True
        meta_kw = ('draft', 'drafting', 'compose', 'composing', 'write', 'writing', 'here is', 'in chinese', '以下是', '草拟', '正在用中文', '用中文')
        if any(k in low for k in meta_kw) and any(k in low for k in ('commit', 'message', '提交', '信息')):
            return True
        if low.startswith('title:') or low.startswith('subject:'):
            return True
        return False

    lines = []
    for raw in message.splitlines():
        s = raw.strip()
        if s == "":
            lines.append("")
            continue
        if (s.startswith('{') and ':' in s):
            continue
        if is_meta_line(s):
            continue
        lines.append(s)
    # trim leading/trailing blanks
    while lines and lines[0] == "":
        lines.pop(0)
    while lines and lines[-1] == "":
        lines.pop()
    if len(lines) > 1 and lines[1] != "":
        lines.insert(1, "")
    return "\n".join(lines).strip()


candidates = [read_text(os.environ.get("RAW_RESPONSE_PATH")), read_text(os.environ.get("RAW_STDOUT_PATH"))]
message = ""
fallbacks = []
for data in filter(None, candidates):
    message = parse_json_blob(data) or parse_json_lines(data)
    if message: break
    fallback = clean(data)
    if fallback: fallbacks.append(fallback)

if not message: message = next(iter(fallbacks), "")
message = strip_meta_blocks(message)
if not message: message = next(iter(fallbacks), "")

print(message.strip())
PY
        )
        MESSAGE_SOURCE="codex"
        [[ -z "$COMMIT_MESSAGE" ]] && CLI_STATUS=1
    fi
fi

# 质量检验：若输出为错误语言或含自述元话术，则触发回退
if (( CLI_STATUS == 0 )); then
  QUALITY_CHECK=$(LANG_PREF="$LANG_PREF" COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os, sys, re
msg = os.environ.get('COMMIT_MESSAGE','')
lang = os.environ.get('LANG_PREF','').lower()

def first_non_empty_line(s: str) -> str:
    for line in s.splitlines():
        t = line.strip()
        if t:
            return t
    return ''

subject = first_non_empty_line(msg)
low = subject.lower()

allow_english = bool(os.environ.get('GIT_COMMIT_AI_ALLOW_ENGLISH'))

if (not allow_english) and any(t in lang for t in ('zh','cn','中文')) and not re.search(r'[\u4e00-\u9fff]', msg):
    print('BAD'); sys.exit(0)

meta_tokens = (
    "i'm ", "i am ", "i will ", "i'll ", "we will ", "we'll ", "let's ",
    "i am carefully", "i'm carefully", "analyzing", "distill", "compose", "writing", "draft", "drafting"
)
if any(tok in low for tok in meta_tokens):
    print('BAD'); sys.exit(0)

print('OK')
PY
)
  if [[ "$QUALITY_CHECK" == "BAD" ]]; then
    QUALITY_REJECTION=1
    REJECTED_MESSAGE="$COMMIT_MESSAGE"
    CLI_STATUS=1
  fi
fi

if (( CLI_STATUS != 0 )); then
  if [[ -n "${QUALITY_REJECTION:-}" ]]; then
    echo "git-commit-ai: 模型输出未通过质量检查，原始结果如下（已过滤）：" >&2
    echo "----------------------------------------" >&2
    printf '%s\n' "$REJECTED_MESSAGE" >&2
    echo "----------------------------------------" >&2
  fi
  FALLBACK_MESSAGE=$(GIT_COMMIT_AI_DIFF_STAT="$DIFF_STAT" \
    GIT_COMMIT_AI_DIFF_OUTPUT="$DIFF_OUTPUT" \
    GIT_COMMIT_AI_LANG="$LANG_PREF" \
    GIT_COMMIT_AI_SUBJECT_STYLE="$SUBJECT_STYLE" \
    python3 - <<'PY'
import os
import re
import sys

stat = os.environ.get('GIT_COMMIT_AI_DIFF_STAT', '')
diff = os.environ.get('GIT_COMMIT_AI_DIFF_OUTPUT', '')
lang = os.environ.get('GIT_COMMIT_AI_LANG', '').lower()
style = os.environ.get('GIT_COMMIT_AI_SUBJECT_STYLE', '')

if not stat.strip() and not diff.strip():
    sys.exit(0)

locale = 'zh'
if lang and not any(token in lang for token in ('zh', 'cn', 'chinese', '中文')):
    locale = 'en'

diff_blocks = []
current_block = None
for line in diff.splitlines():
    if line.startswith('diff --git '):
        if current_block: diff_blocks.append(current_block)
        parts = line.split()
        current_block = {'a': parts[2][2:], 'b': parts[3][2:], 'lines': []}
    if current_block: current_block['lines'].append(line)
if current_block: diff_blocks.append(current_block)

if not diff_blocks and stat:
    for line in stat.splitlines():
        if '|' in line:
            path = line.split('|', 1)[0].strip()
            if path: diff_blocks.append({'a': path, 'b': path, 'lines': [], 'type': 'modify'})

def detect_kind(block):
    if any(line.startswith('new file mode') for line in block['lines']): return 'add'
    if any(line.startswith('deleted file mode') for line in block['lines']): return 'delete'
    if any(line.startswith('rename from') for line in block['lines']): return 'rename'
    return 'modify'

for block in diff_blocks: block['type'] = detect_kind(block)

stat_counts = {}
for line in stat.splitlines():
    if '|' in line:
        path, rest = line.split('|', 1)
        key = path.strip()
        if not key: continue
        pluses = rest.count('+')
        minuses = rest.count('-')
        num_match = re.search(r'(\d+)', rest)
        stat_counts[key] = {'plus': pluses, 'minus': minuses, 'total': int(num_match.group(1)) if num_match else 0}

def shorten(path):
    return path if len(path) <= 40 else os.path.basename(path)

def wrap_subject(text, style_name):
    return f'[{text}]' if style_name == 'brackets' else f'【{text}】' if style_name == 'cn-brackets' else text

labels = {
    'zh': {'add': '新增', 'delete': '移除', 'rename': '重命名', 'modify': '调整', 'add_many': '新增多个文件', 'delete_many': '移除多个文件', 'modify_many': '批量调整文件', 'mixed': '同步多项改动', 'to': '到', 'file': '文件'},
    'en': {'add': 'Add', 'delete': 'Remove', 'rename': 'Rename', 'modify': 'Update', 'add_many': 'Add multiple files', 'delete_many': 'Remove multiple files', 'modify_many': 'Update multiple files', 'mixed': 'Synchronize changes', 'to': 'to', 'file': 'file'}
}
L = labels.get(locale, labels['en'])

def get_subject(blocks):
    if not blocks: return ""
    if len(blocks) == 1:
        b = blocks[0]
        path = b.get('b', b['a']) or L['file']
        item = shorten(path)
        if b['type'] == 'rename':
            src = shorten(next((l.split(' ', 2)[2] for l in b['lines' if b['lines'] else [] if 'lines' in b else []] if l.startswith('rename from')), b['a']))
            dst = shorten(next((l.split(' ', 2)[2] for l in b['lines' if b['lines'] else [] if 'lines' in b else []] if l.startswith('rename to')), b['b']))
            return f"{L['rename']} {src} {L['to']} {dst}"
        return f"{L[b['type']]} {item}"
    
    counts = {k: sum(1 for b in blocks if b['type'] == k) for k in ['add', 'delete', 'modify', 'rename']}
    if counts['add'] == len(blocks): return L['add_many']
    if counts['delete'] == len(blocks): return L['delete_many']
    if counts['modify'] == len(blocks): return L['modify_many']
    return L['mixed']

subject = wrap_subject(get_subject(diff_blocks), style)
if len(subject) > 72: subject = subject[:71] + '…'

body = []
if len(diff_blocks) > 1:
    for b in diff_blocks[:5]:
        line = f"- {get_subject([b])}"
        stats = stat_counts.get(b.get('b', b['a']))
        if stats:
            stat_parts = []
            if stats['plus']: stat_parts.append(f"+{stats['plus']}")
            if stats['minus']: stat_parts.append(f"-{stats['minus']}")
            if stat_parts: line += f" （{'/'.join(stat_parts)}）"
        body.append(line)

if subject:
    print(subject)
    if body:
        print("\n" + "\n".join(body))
PY
  )
  if [[ -n "$FALLBACK_MESSAGE" ]]; then
    USING_FALLBACK=1
    COMMIT_MESSAGE="$FALLBACK_MESSAGE"
    MESSAGE_SOURCE="fallback"
    echo "git-commit-ai: API 调用失败 (exit $CLI_STATUS)，已回退到本地摘要" >&2
  else
    echo "git-commit-ai: API 调用失败 (exit $CLI_STATUS)，且本地摘要生成失败" >&2
    exit "$CLI_STATUS"
  fi
fi

if [[ -z "$COMMIT_MESSAGE" ]]; then
  echo "git-commit-ai: 模型未返回内容" >&2
  if [[ -z "$DEBUG" ]]; then
    echo "(可设置 GIT_COMMIT_AI_DEBUG=1 查看原始输出)" >&2
  fi
  exit 1
fi

if [[ -z "$MESSAGE_SOURCE" ]]; then
  if (( USING_FALLBACK )); then
    MESSAGE_SOURCE="fallback"
  else
    MESSAGE_SOURCE="$API_BACKEND"
  fi
fi

SOURCE_LABEL="生成的提交信息："
case "$MESSAGE_SOURCE" in
  gemini)
    SOURCE_LABEL="Gemini API 生成的提交信息："
    ;;
  codex)
    SOURCE_LABEL="Codex API 生成的提交信息："
    ;;
  fallback)
    SOURCE_LABEL="本地摘要生成的提交信息："
    ;;
esac

## 统一第一行括号风格：整行标题包裹在指定括号内
COMMIT_MESSAGE=$(SUBJECT_STYLE="$SUBJECT_STYLE" COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os
msg = os.environ.get('COMMIT_MESSAGE','')
style = os.environ.get('SUBJECT_STYLE','')
lines = msg.splitlines()

def wrap_full(subject: str, left: str, right: str) -> str:
    s = subject.strip()
    if s.startswith(left):
        s = s[len(left):]
    if s.endswith(right):
        s = s[:-len(right)]
    # 限制标题长度（不含括号）不超过 72 字符
    if len(s) > 72:
        s = s[:71] + '…'
    return f"{left}{s.strip()}{right}"

if lines:
    i = 0
    while i < len(lines) and not lines[i].strip():
        i += 1
    if i < len(lines):
        subj = lines[i]
        if style == 'cn-brackets':
            lines[i] = wrap_full(subj, '【', '】')
        elif style == 'brackets':
            lines[i] = wrap_full(subj, '[', ']')

print('\n'.join(lines))
PY
)

# 限制要点数量并做轻量规范（最多 3 条，适度截断）
COMMIT_MESSAGE=$(COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os
msg = os.environ.get('COMMIT_MESSAGE','')
lines = msg.splitlines()

def normalize_bullets(ls):
    # 找到标题行
    i = 0
    while i < len(ls) and not ls[i].strip():
        i += 1
    if i >= len(ls):
        return ls
    # 确保标题后有一行空行
    j = i + 1
    if j < len(ls) and ls[j].strip():
        ls.insert(j, '')
    # 收集项目符号行
    k = j + 1
    bullets = []
    while k < len(ls):
        s = ls[k].lstrip()
        if s.startswith(('- ', '* ', '• ', '· ')):
            bullets.append((k, ls[k]))
        k += 1
    if not bullets:
        return ls
    # 仅保留前 3 条，轻度截断到 80 字符
    keep = set(idx for idx, _ in bullets[:3])
    for idx, text in bullets:
        if idx in keep:
            t = text.rstrip().rstrip('。；;,.，')
            if len(t) > 80:
                t = t[:79] + '…'
            ls[idx] = t
        else:
            ls[idx] = None
    return [x for x in ls if x is not None]

print('\n'.join(normalize_bullets(lines)))
PY
)

[[ -n "$DEBUG" ]] && {
  echo "[git-commit-ai] 提交信息如下:" >&2
  printf '%s\n' "$COMMIT_MESSAGE" >&2
}

MSG_FILE=$(mktemp "${TMPDIR:-/tmp}/git-commit-msg-XXXXXX")
printf '%s\n' "$COMMIT_MESSAGE" >"$MSG_FILE"

if (( PREVIEW_ONLY )); then
  echo "$SOURCE_LABEL" >&2
  echo "----------------------------------------" >&2
  cat "$MSG_FILE"
  echo "----------------------------------------" >&2
  exit 0
fi

echo "$SOURCE_LABEL" >&2
echo "----------------------------------------" >&2
cat "$MSG_FILE" >&2
echo "----------------------------------------" >&2

run_commit() {
  local commit_msg
  commit_msg=$(cat "$MSG_FILE")
  if (( ${#GIT_ARGS[@]} )); then
    git commit --message "$commit_msg" "${GIT_ARGS[@]}"
  else
    git commit --message "$commit_msg"
  fi
}

if (( AUTO_COMMIT )); then
  run_commit
  exit 0
fi

if (( ASSUME_YES )); then
  run_commit
  exit 0
fi

read -r -p "是否使用该提交信息? [y/N] " REPLY
case "$REPLY" in
  [yY][eE][sS]|[yY])
    run_commit
    ;;
  *)
    echo "git-commit-ai: 已放弃提交（上方已显示生成的消息）" >&2
    ;;
esac
