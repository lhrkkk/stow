#!/usr/bin/env bash
set -euo pipefail

# stowx: helper for managing GNU Stow dotfiles
# Defaults align with your workflows:
#   STOW_DIR: $HOME/_env/stow
#   TARGET:   $HOME
#   Default package: mac-home

usage() {
  cat <<'EOF'
Usage:
  stowx <command> [options] [packages...]

Commands:
  preview       预览变更（等价: stow -nvt "$TARGET" -d "$STOW_DIR" -S <pkgs>）
  apply         应用链接（等价: stow -vt  "$TARGET" -d "$STOW_DIR" -S <pkgs>）
  adopt         收编部署：默认仅 stow -S --adopt；如需覆盖式部署请加 --restore（谨慎）
  grab          抓取文件/文件夹到指定包内并建立链接（stow 化单个路径）
  unstow        取消链接（stow -D）
  restow        重新链接（stow -R）
  list          列出可用包（STOW_DIR 下的目录）
  help          显示帮助

Options:
  -d, --dir <path>       STOW_DIR（默认: $HOME/_env/stow）
  -t, --target <path>    目标目录（默认: $HOME）
  -C, --relative-to-cwd  grab 的相对路径以当前目录($PWD)为基准（默认以 $TARGET）
  -n, --dry-run          预演（为 adopt/apply/unstow/restow 添加 -n）
  -v, --verbose          增强调试输出（为 stow 添加 -v）
  -p, --package <name>   指定包，可重复；也可直接作为位置参数（grab 推荐仅一个包）
      --host[=<name>]    仅操作 hosts/<name> 包（不包含默认包）；不提供参数时自动取 $(hostname)
  -y, --yes              非交互确认危险操作（adopt/覆盖同名目标时）
  -r, --restore          adopt 后执行 git -C <包> restore .（覆盖本地改动）
      --no-restore       兼容保留；默认已不恢复（无效果）
  -f, --force            强制覆盖冲突文件（删除现有文件后重新创建符号链接）

缺省包: mac-home
示例：
  预览:   stowx preview
  应用:   stowx apply                # 部署 mac-home
  主机:   stowx apply --host         # 仅部署 hosts/$(hostname)
  组合:   stowx apply mac-home --host # 错误：--host 不能与其他包组合
  强制:   stowx apply --force -y     # 强制覆盖冲突文件
  覆盖:   stowx adopt -y -r    # 等价 --restore
  抓取:   stowx grab -p mac-home ~/.config/wezterm/wezterm.lua
  抓取:   stowx grab ~/.config/wezterm/wezterm.lua --host
  取消:   stowx unstow --host        # 仅取消主机包链接
EOF
}

log() { printf "[stowx] %s\n" "$*"; }
err() { printf "[stowx][ERR] %s\n" "$*" 1>&2; }
die() { err "$*"; exit 1; }

# Defaults
STOW_DIR=${STOW_DIR:-"$HOME/_env/stow"}
TARGET=${TARGET:-"$HOME"}
VERBOSE=0
DRY_RUN=0
DO_RESTORE=0
YES=0
FORCE=0
USE_CWD=0
USE_HOST=0
HOST_NAME=""
HOST_PACKAGE=""
CMD=""
PACKAGES=()
POSITIONALS=()
PATHS=()
GLOBAL_IGNORE=()

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "未找到命令: $1"; }

default_host() {
  local name
  if command -v hostname >/dev/null 2>&1; then
    name=$(hostname 2>/dev/null || true)
    if [[ -n "$name" ]]; then
      printf '%s' "$name"
      return 0
    fi
  fi
  if command -v uname >/dev/null 2>&1; then
    name=$(uname -n 2>/dev/null || true)
    if [[ -n "$name" ]]; then
      printf '%s' "$name"
      return 0
    fi
  fi
  printf '%s' "unknown-host"
}

ensure_global_ignore_file() {
  local file="$STOW_DIR/.stow-global-ignore"
  if [[ -f "$file" ]]; then
    return 0
  fi
  mkdir -p "$STOW_DIR"
  cat >"$file" <<'EOF'
^\.git(ignore)?$
^\.gitmodules$
# ^WARP\.md$
^\.specstory$
^\.cursor$
^\.stow-local-ignore$
\.DS_Store$
^\.cursorindexingignore$
^\.cursorrules$
^\.cursorignore$
^\.cursorignorerules$
# common temp/cache
(^|/)cache(/|$)
(^|/)Cache(/|$)
(^|/)tmp(/|$)
(^|/)SavedState(/|$)
(^|/)sockets(/|$)
(^|/)__pycache__(/|$)
(^|/).+\.zwc$
(^|/)\.aider(/|$)
(^|/)\.claude(/|$)
(^|/)#detach(/|$)
# third-party git content
(^|/)tmux/plugins(/|$)
(^|/)tpm(/|$)
# common files
(^|/)\.DS_Store$
(^|/)\.git($|/)
^README(\.md)?$
(^|/)README\.md$
(^|/)LICENSE$
EOF
  log "已创建默认 .stow-global-ignore"
  log "请核对内容后按需调整（文件首次生成时仅包含默认规则）"
}

ensure_local_ignore_file() {
  local pkg_dir="$1"
  local file="$pkg_dir/.stow-local-ignore"
  local ensure_pattern='(^|/)_env(/|$)'
  if [[ -f "$file" ]]; then
    if ! grep -Eq "$ensure_pattern" "$file"; then
      printf '%s\n' "$ensure_pattern" >>"$file"
      local rel="${pkg_dir#$STOW_DIR/}"
      rel=${rel:-${pkg_dir}}
      log "已向 $rel/.stow-local-ignore 追加: $ensure_pattern"
    fi
    return 0
  fi
  mkdir -p "$pkg_dir"
  cat >"$file" <<'EOF'
^\.git(ignore)?$
^\.gitmodules$
# ^WARP\.md$
^\.specstory$
^\.cursor$
\.DS_Store$
^\.cursorindexingignore$
^\.cursorrules$
^\.cursorignore$
^\.cursorignorerules$
# common temp/cache
(^|/)cache(/|$)
(^|/)Cache(/|$)
(^|/)tmp(/|$)
(^|/)SavedState(/|$)
(^|/)sockets(/|$)
(^|/)__pycache__(/|$)
(^|/).+\.zwc$
(^|/)\.aider(/|$)
(^|/)\.claude(/|$)
(^|/)#detach(/|$)
# avoid capturing STOW_DIR 本体
(^|/)_env(/|$)
# third-party git content
(^|/)tmux/plugins(/|$)
(^|/)tpm(/|$)
# common files
(^|/)\.DS_Store$
(^|/)\.git($|/)
^README(\.md)?$
(^|/)README\.md$
(^|/)LICENSE$
EOF
  local rel="${pkg_dir#$STOW_DIR/}"
  rel=${rel:-${pkg_dir}}
  log "已在 $rel 创建默认 .stow-local-ignore"
  log "请核对内容后按需调整（文件首次生成时仅包含默认规则）"
}

# Load .stow-global-ignore from STOW_DIR (regex patterns, one per line)
load_global_ignore() {
  GLOBAL_IGNORE=()
  local f="$STOW_DIR/.stow-global-ignore"
  if [[ -f "$f" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      # skip empty lines and comments
      [[ -z "$line" ]] && continue
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      GLOBAL_IGNORE+=("$line")
    done < "$f"
  fi
}

# Return 0 if name matches any global ignore regex
pkg_ignored() {
  local name="$1"
  if [[ ${#GLOBAL_IGNORE[@]} -eq 0 ]]; then return 1; fi
  for pat in "${GLOBAL_IGNORE[@]}"; do
    if [[ "$name" =~ $pat ]]; then return 0; fi
  done
  return 1
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      preview|apply|adopt|grab|unstow|restow|list|help)
        CMD="$1"; shift ;;
      -d|--dir)
        [[ $# -ge 2 ]] || die "--dir 需要参数"; STOW_DIR="$2"; shift 2 ;;
      -t|--target)
        [[ $# -ge 2 ]] || die "--target 需要参数"; TARGET="$2"; shift 2 ;;
      -C|--relative-to-cwd)
        USE_CWD=1; shift ;;
      -n|--dry-run)
        DRY_RUN=1; shift ;;
      -v|--verbose)
        VERBOSE=1; shift ;;
      --host)
        USE_HOST=1
        if [[ $# -ge 2 && ${2-} != -* ]]; then
          HOST_NAME="$2"
          shift 2
        else
          HOST_NAME=$(default_host)
          shift
        fi
        ;;
      --host=*)
        USE_HOST=1
        HOST_NAME="${1#--host=}"
        if [[ -z "$HOST_NAME" ]]; then
          HOST_NAME=$(default_host)
        fi
        shift ;;
      -p|--package)
        [[ $# -ge 2 ]] || die "--package 需要参数"; PACKAGES+=("$2"); shift 2 ;;
      -y|--yes)
        YES=1; shift ;;
      -r|--restore)
        DO_RESTORE=1; shift ;;
      --no-restore)
        # 兼容参数：默认已不恢复
        DO_RESTORE=0; shift ;;
      -f|--force)
        FORCE=1; shift ;;
      --)
        shift; break ;;
      -h|--help)
        CMD="help"; shift ;;
      *)
        POSITIONALS+=("$1"); shift ;;
    esac
  done
  # consume rest as positionals
  while [[ $# -gt 0 ]]; do POSITIONALS+=("$1"); shift; done
}

confirm() {
  local prompt="$1"
  if [[ $YES -eq 1 ]]; then return 0; fi
  read -r -p "$prompt [y/N] " ans || true
  [[ "$ans" == "y" || "$ans" == "Y" ]] || return 1
}

build_opts() {
  STOW_OPTS=( -t "$TARGET" -d "$STOW_DIR" )
  if [[ $VERBOSE -eq 1 ]]; then STOW_OPTS=( -v "${STOW_OPTS[@]}" ); fi
  if [[ $DRY_RUN -eq 1 ]]; then STOW_OPTS=( -n "${STOW_OPTS[@]}" ); fi
}

run_stow() {
  need_cmd stow
  build_opts
  local subopts=("$@")
  local -a normal=()
  local -a nested=()
  local p
  for p in "${PACKAGES[@]}"; do
    case "$p" in
      */*) nested+=("$p") ;;
      *)   normal+=("$p") ;;
    esac
  done

  if [[ ${#normal[@]} -gt 0 ]]; then
    local -a sep=()
    for p in "${normal[@]}"; do
      case "$p" in
        -*) sep=(--); break ;;
      esac
    done
    if [[ ${#sep[@]} -gt 0 ]]; then
      log "stow ${STOW_OPTS[*]} ${subopts[*]} -- ${normal[*]}"
      stow "${STOW_OPTS[@]}" "${subopts[@]}" -- "${normal[@]}" || return $?
    else
      log "stow ${STOW_OPTS[*]} ${subopts[*]} ${normal[*]}"
      stow "${STOW_OPTS[@]}" "${subopts[@]}" "${normal[@]}" || return $?
    fi
  fi

  if [[ ${#nested[@]} -gt 0 ]]; then
    local base name dir
    for p in "${nested[@]}"; do
      base=${p%/*}
      name=${p##*/}
      dir="$STOW_DIR/$base"
      if [[ ! -d "$dir/$name" ]]; then
        err "跳过：包不存在 -> $dir/$name"
        continue
      fi
      local -a opts=( -t "$TARGET" -d "$dir" )
      if [[ $VERBOSE -eq 1 ]]; then opts=( -v "${opts[@]}" ); fi
      if [[ $DRY_RUN -eq 1 ]]; then opts=( -n "${opts[@]}" ); fi
      log "stow ${opts[*]} ${subopts[*]} ${name}"
      case "$name" in
        -*) stow "${opts[@]}" "${subopts[@]}" -- "$name" || return $? ;;
        *)  stow "${opts[@]}" "${subopts[@]}" "$name" || return $? ;;
      esac
    done
  fi
}

ensure_packages() {
  local had_explicit=0
  if [[ ${#PACKAGES[@]} -gt 0 ]]; then
    had_explicit=1
  fi

  if [[ $USE_HOST -eq 1 && -z "$HOST_PACKAGE" ]]; then
    HOST_NAME=${HOST_NAME:-$(default_host)}
    HOST_PACKAGE="hosts/$HOST_NAME"
  fi

  if [[ $USE_HOST -eq 1 ]]; then
    # --host 选项：只操作 host 包，不包含默认包
    if [[ $had_explicit -eq 1 ]]; then
      die "--host 与明确指定的包冲突，请选择其一"
    fi
    PACKAGES=("$HOST_PACKAGE")
  else
    # 非 --host 模式：使用默认包逻辑
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
      PACKAGES=("mac-home")
    fi
  fi

  ensure_global_ignore_file
  load_global_ignore
  for p in "${PACKAGES[@]}"; do
    if [[ $p == hosts/* ]]; then
      ensure_local_ignore_file "$STOW_DIR/$p"
    fi
    if pkg_ignored "$p"; then
      die "包名被 .stow-global-ignore 规则匹配：$p"
    fi
  done
}

# Normalize a source path: expand leading ~, make absolute relative to base (TARGET by default, or CWD when -C)
norm_src() {
  local p="$1"
  [[ "$p" == ~* ]] && p="${p/#~/$HOME}"
  if [[ "$p" != /* ]]; then
    if [[ $USE_CWD -eq 1 ]]; then
      p="$PWD/$p"
    else
      p="$TARGET/$p"
    fi
  fi
  printf '%s' "$p"
}

# Ensure a path resides under $TARGET and return its relative form
rel_under_target() {
  local abs="$1"
  case "$abs" in
    "$TARGET"/*) printf '%s' "${abs#${TARGET}/}" ;;
    *) return 1 ;;
  esac
}

# Force remove conflicting files/symlinks before applying
force_remove_conflicts() {
  local pkg target_file pkg_file
  for pkg in "${PACKAGES[@]}"; do
    case "$pkg" in
      */*)
        # 嵌套包（如 hosts/VM-0-10-centos）
        local base=${pkg%/*}
        local name=${pkg##*/}
        local pkg_dir="$STOW_DIR/$base/$name"
        ;;
      *)
        # 普通包
        local pkg_dir="$STOW_DIR/$pkg"
        ;;
    esac
    
    if [[ ! -d "$pkg_dir" ]]; then
      log "跳过：包目录不存在 -> $pkg_dir"
      continue
    fi
    
    # Find all files in the package and check for conflicts
    while IFS= read -r -d '' pkg_file; do
      local rel_path="${pkg_file#$pkg_dir/}"
      local target_file="$TARGET/$rel_path"
      if [[ -e "$target_file" || -L "$target_file" ]]; then
        if [[ $YES -eq 1 ]]; then
          log "强制删除冲突文件: $target_file"
          rm -rf "$target_file"
        else
          confirm "删除冲突文件 $target_file ?" || continue
          rm -rf "$target_file"
        fi
      fi
    done < <(find "$pkg_dir" -type f -print0)
  done
}

# Force remove conflicts by checking stow dry-run output
force_remove_conflicts_by_stow_check() {
  log "检查 stow 冲突并强制删除..."
  local temp_output
  temp_output=$(mktemp)
  
  # Run stow dry-run to detect conflicts
  if run_stow -n -S 2>"$temp_output"; then
    log "没有发现冲突"
    rm -f "$temp_output"
    return 0
  fi
  
  # Parse conflict files from stow error output
  local conflict_files=()
  while IFS= read -r line; do
    if [[ "$line" =~ existing\ target\ is\ not\ owned\ by\ stow:\ (.+) ]]; then
      local file="${BASH_REMATCH[1]}"
      local full_path="$TARGET/$file"
      conflict_files+=("$full_path")
    elif [[ "$line" =~ existing\ target\ is\ stowed\ to\ a\ different\ package:\ ([^[:space:]]+) ]]; then
      local file="${BASH_REMATCH[1]}"
      local full_path="$TARGET/$file"
      conflict_files+=("$full_path")
    fi
  done < "$temp_output"
  
  rm -f "$temp_output"
  
  if [[ ${#conflict_files[@]} -eq 0 ]]; then
    log "未发现可解析的冲突文件"
    return 0
  fi
  
  # Remove conflict files
  for file in "${conflict_files[@]}"; do
    if [[ -e "$file" || -L "$file" ]]; then
      if [[ $YES -eq 1 ]]; then
        log "强制删除冲突文件: $file"
        rm -rf "$file"
      else
        confirm "删除冲突文件 $file ?" || continue
        rm -rf "$file"
      fi
    fi
  done
}

cmd_preview() { ensure_packages; run_stow -n -v -S; }
cmd_apply()   { 
  ensure_packages
  if [[ $FORCE -eq 1 ]]; then
    force_remove_conflicts_by_stow_check
  fi
  run_stow -S
}
cmd_unstow()  { ensure_packages; run_stow -D; }
cmd_restow()  { ensure_packages; run_stow -R; }

cmd_grab() {
  ensure_packages
  if [[ ${#PACKAGES[@]} -gt 1 ]]; then
    die "grab 目前仅支持单个包，请用 -p 指定一个包（当前: ${PACKAGES[*]}）"
  fi
  local pkg="${PACKAGES[0]}"
  if [[ ${#PATHS[@]} -eq 0 ]]; then
    die "grab 需要至少一个要抓取的路径"
  fi
  need_cmd mkdir; need_cmd mv
  local moved_any=0
  for src_in in "${PATHS[@]}"; do
    local abs src rel dst dstdir
    abs=$(norm_src "$src_in")
    if [[ ! -e "$abs" ]]; then
      err "跳过：不存在的路径 -> $abs"
      continue
    fi
    rel=$(rel_under_target "$abs") || { err "跳过：不在 TARGET 范围内 -> $abs"; continue; }
    dst="$STOW_DIR/$pkg/$rel"
    dstdir=$(dirname "$dst")
    if [[ $DRY_RUN -eq 1 ]]; then
      log "DRY-RUN: + mkdir -p \"$dstdir\""
      if [[ -e "$dst" ]]; then
        log "DRY-RUN: + rm -rf \"$dst\""
      fi
      log "DRY-RUN: + mv \"$abs\" \"$dst\""
    else
      log "+ mkdir -p \"$dstdir\""
      mkdir -p "$dstdir"
      if [[ -e "$dst" ]]; then
        if [[ $YES -eq 1 ]]; then
          log "目标已存在，覆盖：$dst"
          log "+ rm -rf \"$dst\""
          rm -rf "$dst"
        else
          confirm "目标已存在：$dst。是否覆盖？" || { err "已跳过 $abs"; continue; }
          log "+ rm -rf \"$dst\""
          rm -rf "$dst"
        fi
      fi
      log "+ mv \"$abs\" \"$dst\""
      mv "$abs" "$dst"
      moved_any=1
      log "已移动：$abs -> $dst"
    fi
  done
  # After moving, restow the package to create symlinks
  if [[ $DRY_RUN -eq 1 ]]; then
    # 构建等效的 stow 选项并打印将执行的命令（均为模拟模式）
    build_opts
    # 确保预览输出包含 -n（如果未通过 -n 指定，build_opts 不会注入；此处手动保证）
    case " ${STOW_OPTS[*]} " in
      *" -n "*) : ;;
      *) STOW_OPTS=( -n "${STOW_OPTS[@]}" ) ;;
    esac
    log "DRY-RUN: + stow ${STOW_OPTS[*]} -R -- ${PACKAGES[*]}"
    log "DRY-RUN: + stow ${STOW_OPTS[*]} -S -- ${PACKAGES[*]}"
  else
    # Prefer restow; if it fails (e.g. first time, nothing to restow), fallback to apply (-S)
    if run_stow -R; then
      :
    else
      log "restow 失败，尝试 apply (-S)"
      run_stow -S
    fi
  fi
}

cmd_adopt() {
  ensure_packages
  if [[ $DRY_RUN -eq 1 ]]; then
    log "adopt 以干跑模式执行"
    run_stow -S --adopt
    return 0
  fi
  local prompt
  if [[ $DO_RESTORE -eq 1 ]]; then
    prompt="将以覆盖式部署（--adopt + git restore .）覆盖工作区改动。确认继续吗？"
  else
    prompt="将以收编部署（--adopt，仅收编不恢复），不会自动覆盖仓库改动。确认继续吗？"
  fi
  confirm "$prompt" || die "已取消"
  run_stow -S --adopt
  if [[ $DO_RESTORE -eq 1 ]]; then
    for pkg in "${PACKAGES[@]}"; do
      local repo="$STOW_DIR/$pkg"
      if git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log "+ git -C \"$repo\" restore ."
        git -C "$repo" restore .
      else
        log "跳过 git restore：$repo 不是 git 仓库"
      fi
    done
  else
    log "已跳过 git restore ."
  fi
}

cmd_list() {
  [[ -d "$STOW_DIR" ]] || die "STOW_DIR 不存在: $STOW_DIR"
  ensure_global_ignore_file
  load_global_ignore
  local -a top_dirs=()
  while IFS= read -r name; do
    top_dirs+=("$name")
  done < <(find "$STOW_DIR" -mindepth 1 -maxdepth 1 -type d -prune -exec basename {} \; | sort)

  local name
  for name in "${top_dirs[@]}"; do
    if pkg_ignored "$name"; then
      continue
    fi
    case "$name" in
      hosts|mods)
        echo "$name/"
        local dir="$STOW_DIR/$name"
        if [[ -d "$dir" ]]; then
          while IFS= read -r sub; do
            local rel="$name/$sub"
            if pkg_ignored "$rel"; then
              continue
            fi
            echo "  $sub"
          done < <(find "$dir" -mindepth 1 -maxdepth 1 -type d -prune -exec basename {} \; | sort)
        fi
        ;;
      *)
        echo "$name"
        ;;
    esac
  done
}

main() {
  parse_args "$@"

  if [[ $USE_HOST -eq 1 ]]; then
    HOST_NAME=${HOST_NAME:-$(default_host)}
    HOST_PACKAGE="hosts/$HOST_NAME"
  fi

  # Map POSITIONALS depending on command
  if [[ "${CMD:-}" == "grab" ]]; then
    PATHS=("${POSITIONALS[@]}")
  else
    if [[ ${#PACKAGES[@]} -eq 0 && ${#POSITIONALS[@]} -gt 0 ]]; then
      PACKAGES=("${POSITIONALS[@]}")
    fi
  fi
  case "${CMD:-}" in
    preview) cmd_preview ;;
    apply)   cmd_apply   ;;
    adopt)   cmd_adopt   ;;
    grab)    cmd_grab    ;;
    unstow)  cmd_unstow  ;;
    restow)  cmd_restow  ;;
    list)    cmd_list    ;;
    help|"") usage ;;
    *) err "未知命令: $CMD"; usage; exit 2 ;;
  esac
}

main "$@"
