#!/usr/bin/env bash
set -euo pipefail

# stowx: helper for managing GNU Stow dotfiles
# Defaults align with your workflows:
#   STOW_DIR: $HOME/_env/stow
#   TARGET:   $HOME
#   Default package: mac-home

usage() {
  cat <<'EOF'
Usage:
  stowx <command> [options] [packages...]

Commands:
  preview       预览变更（等价: stow -nvt "$TARGET" -d "$STOW_DIR" -S <pkgs>）
  apply         应用链接（等价: stow -vt  "$TARGET" -d "$STOW_DIR" -S <pkgs>）
  auto          依次执行：apply --force -y 与 apply --host --force -y（-n 时为干跑）
  adopt         收编部署：默认仅 stow -S --adopt；如需覆盖式部署请加 --restore（谨慎）
  grab          抓取文件/文件夹到指定包内并建立链接（stow 化单个路径）
  putback       反向于 grab：从包复制文件到目标（不移动，保留包内原件）
  unstow        取消链接（stow -D）
  restow        重新链接（stow -R）
  list          列出可用包（STOW_DIR 下的目录）
  help          显示帮助

Options:
  -d, --dir <path>       STOW_DIR（默认: $HOME/_env/stow）
  -t, --target <path>    目标目录（默认: $HOME）
  -C, --relative-to-cwd  grab 的相对路径以当前目录($PWD)为基准（默认以 $TARGET）
  -n, --dry-run          预演（为 adopt/apply/unstow/restow 添加 -n）
  -v, --verbose          增强调试输出（为 stow 添加 -v）
  -p, --package <name>   指定包，可重复；也可直接作为位置参数（grab 推荐仅一个包）
      --host[=<name>]    仅操作 hosts/<name> 包（不包含默认包）；不提供参数时自动取 $(hostname)
  -y, --yes              非交互确认危险操作（adopt/覆盖同名目标时）
  -r, --restore          adopt 后执行 git -C <包> restore .（覆盖本地改动）
      --no-restore       兼容保留；默认已不恢复（无效果）
  -f, --force            冲突解析（apply/restow 生效：交互式 override/defer；配合 -y 默认 override）
      --defer <regex>    推迟处理匹配正则的文件（传递给 stow --defer）
      --override <regex> 覆盖匹配正则的文件（传递给 stow --override）
      --ignore <regex>   忽略匹配正则的路径（传递给 stow --ignore）
      --allow-non-symlink  putback 允许覆盖/创建“非符号链接”的目标（默认仅处理符号链接）

缺省包: mac-home
示例：
  预览:   stowx preview
  应用:   stowx apply                # 部署 mac-home
  主机:   stowx apply --host         # 仅部署 hosts/$(hostname)
  自动:   stowx auto                 # 先 mac-home 再 hosts/<hostname>（支持 -n 干跑）
  组合:   stowx apply mac-home --host # 错误：--host 不能与其他包组合
  强制:   stowx apply --force -y     # 强制覆盖冲突文件（交互/非交互）
  强制:   stowx restow --force -y    # restow 同样支持冲突解析
  推迟:   stowx apply --defer '\.bashrc$' # 推迟匹配路径的处理（不用于现存冲突）
  覆盖:   stowx apply --override '\.zshrc$' # 强制覆盖 .zshrc  
  收编:   stowx adopt -y -r    # 等价 --restore
  抓取:   stowx grab -p mac-home ~/.config/wezterm/wezterm.lua
  放回:   stowx putback -p mac-home ~/.config/wezterm/wezterm.lua
  抓取:   stowx grab ~/.config/wezterm/wezterm.lua --host
  取消:   stowx unstow --host        # 仅取消主机包链接
EOF
}

log() { printf "[stowx] %s\n" "$*"; }
err() { printf "[stowx][ERR] %s\n" "$*" 1>&2; }
die() { err "$*"; exit 1; }

# Defaults
STOW_DIR=${STOW_DIR:-"$HOME/_env/stow"}
TARGET=${TARGET:-"$HOME"}
VERBOSE=0
DRY_RUN=0
DO_RESTORE=0
YES=0
FORCE=0
DEFER_PATTERNS=()
OVERRIDE_PATTERNS=()
IGNORE_PATTERNS=()
ALLOW_NON_SYMLINK=0
USE_CWD=0
USE_HOST=0
HOST_NAME=""
HOST_PACKAGE=""
CMD=""
PACKAGES=()
POSITIONALS=()
PATHS=()
GLOBAL_IGNORE=()

need_cmd() { command -v "$1" >/dev/null 2>&1 || die "未找到命令: $1"; }

default_host() {
  local name
  if command -v hostname >/dev/null 2>&1; then
    name=$(hostname 2>/dev/null || true)
    if [[ -n "$name" ]]; then
      printf '%s' "$name"
      return 0
    fi
  fi
  if command -v uname >/dev/null 2>&1; then
    name=$(uname -n 2>/dev/null || true)
    if [[ -n "$name" ]]; then
      printf '%s' "$name"
      return 0
    fi
  fi
  printf '%s' "unknown-host"
}

ensure_global_ignore_file() {
  local file="$STOW_DIR/.stow-global-ignore"
  if [[ -f "$file" ]]; then
    return 0
  fi
  mkdir -p "$STOW_DIR"
  cat >"$file" <<'EOF'
^\.git(ignore)?$
^\.gitmodules$
# ^WARP\.md$
^\.specstory$
^\.cursor$
^\.stow-local-ignore$
\.DS_Store$
^\.cursorindexingignore$
^\.cursorrules$
^\.cursorignore$
^\.cursorignorerules$
# common temp/cache
(^|/)cache(/|$)
(^|/)Cache(/|$)
(^|/)tmp(/|$)
(^|/)SavedState(/|$)
(^|/)sockets(/|$)
(^|/)__pycache__(/|$)
(^|/).+\.zwc$
(^|/)\.aider(/|$)
(^|/)\.claude(/|$)
(^|/)#detach(/|$)
# third-party git content
(^|/)tmux/plugins(/|$)
(^|/)tpm(/|$)
# common files
(^|/)\.DS_Store$
(^|/)\.git($|/)
^README(\.md)?$
(^|/)README\.md$
(^|/)LICENSE$
EOF
  log "已创建默认 .stow-global-ignore"
  log "请核对内容后按需调整（文件首次生成时仅包含默认规则）"
}

ensure_local_ignore_file() {
  local pkg_dir="$1"
  local file="$pkg_dir/.stow-local-ignore"
  local ensure_pattern='(^|/)_env(/|$)'
  if [[ -f "$file" ]]; then
    if ! grep -Eq "$ensure_pattern" "$file"; then
      printf '%s\n' "$ensure_pattern" >>"$file"
      local rel="${pkg_dir#$STOW_DIR/}"
      rel=${rel:-${pkg_dir}}
      log "已向 $rel/.stow-local-ignore 追加: $ensure_pattern"
    fi
    return 0
  fi
  mkdir -p "$pkg_dir"
  cat >"$file" <<'EOF'
^\.git(ignore)?$
^\.gitmodules$
# ^WARP\.md$
^\.specstory$
^\.cursor$
\.DS_Store$
^\.cursorindexingignore$
^\.cursorrules$
^\.cursorignore$
^\.cursorignorerules$
# common temp/cache
(^|/)cache(/|$)
(^|/)Cache(/|$)
(^|/)tmp(/|$)
(^|/)SavedState(/|$)
(^|/)sockets(/|$)
(^|/)__pycache__(/|$)
(^|/).+\.zwc$
(^|/)\.aider(/|$)
(^|/)\.claude(/|$)
(^|/)#detach(/|$)
# avoid capturing STOW_DIR 本体
(^|/)_env(/|$)
# third-party git content
(^|/)tmux/plugins(/|$)
(^|/)tpm(/|$)
# common files
(^|/)\.DS_Store$
(^|/)\.git($|/)
^README(\.md)?$
(^|/)README\.md$
(^|/)LICENSE$
EOF
  local rel="${pkg_dir#$STOW_DIR/}"
  rel=${rel:-${pkg_dir}}
  log "已在 $rel 创建默认 .stow-local-ignore"
  log "请核对内容后按需调整（文件首次生成时仅包含默认规则）"
}

# Load .stow-global-ignore from STOW_DIR (regex patterns, one per line)
load_global_ignore() {
  GLOBAL_IGNORE=()
  local f="$STOW_DIR/.stow-global-ignore"
  if [[ -f "$f" ]]; then
    while IFS= read -r line || [[ -n "$line" ]]; do
      # skip empty lines and comments
      [[ -z "$line" ]] && continue
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      GLOBAL_IGNORE+=("$line")
    done < "$f"
  fi
}

# Return 0 if name matches any global ignore regex
pkg_ignored() {
  local name="$1"
  if [[ ${#GLOBAL_IGNORE[@]} -eq 0 ]]; then return 1; fi
  for pat in "${GLOBAL_IGNORE[@]}"; do
    if [[ "$name" =~ $pat ]]; then return 0; fi
  done
  return 1
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      preview|apply|auto|adopt|grab|putback|unstow|restow|list|help)
        CMD="$1"; shift ;;
      -d|--dir)
        [[ $# -ge 2 ]] || die "--dir 需要参数"; STOW_DIR="$2"; shift 2 ;;
      -t|--target)
        [[ $# -ge 2 ]] || die "--target 需要参数"; TARGET="$2"; shift 2 ;;
      -C|--relative-to-cwd)
        USE_CWD=1; shift ;;
      -n|--dry-run)
        DRY_RUN=1; shift ;;
      -v|--verbose)
        VERBOSE=1; shift ;;
      --host)
        USE_HOST=1
        if [[ $# -ge 2 && ${2-} != -* ]]; then
          HOST_NAME="$2"
          shift 2
        else
          HOST_NAME=$(default_host)
          shift
        fi
        ;;
      --host=*)
        USE_HOST=1
        HOST_NAME="${1#--host=}"
        if [[ -z "$HOST_NAME" ]]; then
          HOST_NAME=$(default_host)
        fi
        shift ;;
      -p|--package)
        [[ $# -ge 2 ]] || die "--package 需要参数"; PACKAGES+=("$2"); shift 2 ;;
      -y|--yes)
        YES=1; shift ;;
      -r|--restore)
        DO_RESTORE=1; shift ;;
      --no-restore)
        # 兼容参数：默认已不恢复
        DO_RESTORE=0; shift ;;
      -f|--force)
        FORCE=1; shift ;;
      --defer)
        [[ $# -ge 2 ]] || die "--defer 需要参数"; DEFER_PATTERNS+=("$2"); shift 2 ;;
      --override)
        [[ $# -ge 2 ]] || die "--override 需要参数"; OVERRIDE_PATTERNS+=("$2"); shift 2 ;;
      --ignore)
        [[ $# -ge 2 ]] || die "--ignore 需要参数"; IGNORE_PATTERNS+=("$2"); shift 2 ;;
      --allow-non-symlink)
        ALLOW_NON_SYMLINK=1; shift ;;
      --)
        shift; break ;;
      -h|--help)
        CMD="help"; shift ;;
      *)
        POSITIONALS+=("$1"); shift ;;
    esac
  done
  # consume rest as positionals
  while [[ $# -gt 0 ]]; do POSITIONALS+=("$1"); shift; done
}

confirm() {
  local prompt="$1"
  if [[ $YES -eq 1 ]]; then return 0; fi
  read -r -p "$prompt [y/N] " ans || true
  [[ "$ans" == "y" || "$ans" == "Y" ]] || return 1
}

build_opts() {
  STOW_OPTS=( -t "$TARGET" -d "$STOW_DIR" )
  if [[ $VERBOSE -eq 1 ]]; then STOW_OPTS=( -v "${STOW_OPTS[@]}" ); fi
  if [[ $DRY_RUN -eq 1 ]]; then STOW_OPTS=( -n "${STOW_OPTS[@]}" ); fi
  
  # Add defer patterns
  for pattern in "${DEFER_PATTERNS[@]}"; do
    STOW_OPTS=( "${STOW_OPTS[@]}" "--defer" "$pattern" )
  done
  
  # Add override patterns  
  for pattern in "${OVERRIDE_PATTERNS[@]}"; do
    STOW_OPTS=( "${STOW_OPTS[@]}" "--override" "$pattern" )
  done
  
  # Add ignore patterns
  for pattern in "${IGNORE_PATTERNS[@]}"; do
    STOW_OPTS=( "${STOW_OPTS[@]}" "--ignore" "$pattern" )
  done
  
  # Debug output if verbose
  if [[ $VERBOSE -eq 1 && ${#DEFER_PATTERNS[@]} -gt 0 ]]; then
    log "Defer 模式: ${DEFER_PATTERNS[*]}"
  fi
}

run_stow() {
  need_cmd stow
  build_opts
  local subopts=("$@")
  local -a normal=()
  local -a nested=()
  local p
  for p in "${PACKAGES[@]}"; do
    case "$p" in
      */*) nested+=("$p") ;;
      *)   normal+=("$p") ;;
    esac
  done

  if [[ ${#normal[@]} -gt 0 ]]; then
    local -a sep=()
    for p in "${normal[@]}"; do
      case "$p" in
        -*) sep=(--); break ;;
      esac
    done
    # Show quoted command for debug
    local cmd_display="stow"
    for arg in "${STOW_OPTS[@]}" "${subopts[@]}"; do
      if [[ "$arg" =~ [[:space:]\$\^] ]]; then
        cmd_display="$cmd_display \"$arg\""
      else
        cmd_display="$cmd_display $arg"
      fi
    done
    
    if [[ ${#sep[@]} -gt 0 ]]; then
      cmd_display="$cmd_display -- ${normal[*]}"
      log "$cmd_display"
      stow "${STOW_OPTS[@]}" "${subopts[@]}" -- "${normal[@]}" || return $?
    else
      cmd_display="$cmd_display ${normal[*]}"
      log "$cmd_display"
      stow "${STOW_OPTS[@]}" "${subopts[@]}" "${normal[@]}" || return $?
    fi
  fi

  if [[ ${#nested[@]} -gt 0 ]]; then
    local base name dir
    for p in "${nested[@]}"; do
      base=${p%/*}
      name=${p##*/}
      dir="$STOW_DIR/$base"
      if [[ ! -d "$dir/$name" ]]; then
        err "跳过：包不存在 -> $dir/$name"
        continue
      fi
      local -a opts=( -t "$TARGET" -d "$dir" )
      if [[ $VERBOSE -eq 1 ]]; then opts=( -v "${opts[@]}" ); fi
      if [[ $DRY_RUN -eq 1 ]]; then opts=( -n "${opts[@]}" ); fi
      
      # Add defer patterns for nested packages too
      for pattern in "${DEFER_PATTERNS[@]}"; do
        opts=( "${opts[@]}" "--defer" "$pattern" )
      done
      
      # Add override patterns for nested packages too
      for pattern in "${OVERRIDE_PATTERNS[@]}"; do
        opts=( "${opts[@]}" "--override" "$pattern" )
      done
      
      # Add ignore patterns for nested packages too
      for pattern in "${IGNORE_PATTERNS[@]}"; do
        opts=( "${opts[@]}" "--ignore" "$pattern" )
      done
      
      # Show quoted command for debug
      local cmd_display="stow"
      for arg in "${opts[@]}" "${subopts[@]}"; do
        if [[ "$arg" =~ [[:space:]\$\^] ]]; then
          cmd_display="$cmd_display \"$arg\""
        else
          cmd_display="$cmd_display $arg"
        fi
      done
      cmd_display="$cmd_display $name"
      log "$cmd_display"
      
      case "$name" in
        -*) stow "${opts[@]}" "${subopts[@]}" -- "$name" || return $? ;;
        *)  stow "${opts[@]}" "${subopts[@]}" "$name" || return $? ;;
      esac
    done
  fi
}

ensure_packages() {
  local had_explicit=0
  if [[ ${#PACKAGES[@]} -gt 0 ]]; then
    had_explicit=1
  fi

  # Auto-detect package from current directory when none specified
  if [[ $had_explicit -eq 0 && ${USE_HOST:-0} -eq 0 ]]; then
    case "$PWD" in
      "$STOW_DIR"/hosts/*/*)
        # e.g. $STOW_DIR/hosts/<host>/sub/...
        local rest="${PWD#"$STOW_DIR/hosts/"}"
        local host="${rest%%/*}"
        if [[ -n "$host" && -d "$STOW_DIR/hosts/$host" ]]; then
          USE_HOST=1
          HOST_NAME="$host"
          HOST_PACKAGE="hosts/$HOST_NAME"
          PACKAGES=("$HOST_PACKAGE")
          had_explicit=1
        fi
        ;;
      "$STOW_DIR"/*)
        # e.g. $STOW_DIR/<pkg>/sub/...
        local sub="${PWD#"$STOW_DIR/"}"
        local pkg_guess="${sub%%/*}"
        if [[ -n "$pkg_guess" && -d "$STOW_DIR/$pkg_guess" ]]; then
          PACKAGES=("$pkg_guess")
          had_explicit=1
        fi
        ;;
    esac
  fi

  if [[ $USE_HOST -eq 1 && -z "$HOST_PACKAGE" ]]; then
    HOST_NAME=${HOST_NAME:-$(default_host)}
    HOST_PACKAGE="hosts/$HOST_NAME"
  fi

  if [[ $USE_HOST -eq 1 ]]; then
    # --host 选项：只操作 host 包，不包含默认包
    if [[ $had_explicit -eq 1 ]]; then
      die "--host 与明确指定的包冲突，请选择其一"
    fi
    PACKAGES=("$HOST_PACKAGE")
  else
    # 非 --host 模式：使用默认包逻辑
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
      PACKAGES=("mac-home")
    fi
  fi

  ensure_global_ignore_file
  load_global_ignore
  for p in "${PACKAGES[@]}"; do
    if [[ $p == hosts/* ]]; then
      ensure_local_ignore_file "$STOW_DIR/$p"
    fi
    if pkg_ignored "$p"; then
      die "包名被 .stow-global-ignore 规则匹配：$p"
    fi
  done
}

# Normalize a source path: expand leading ~, make absolute relative to base (TARGET by default, or CWD when -C)
norm_src() {
  local p="$1"
  [[ "$p" == ~* ]] && p="${p/#~/$HOME}"
  if [[ "$p" != /* ]]; then
    if [[ $USE_CWD -eq 1 ]]; then
      p="$PWD/$p"
    else
      p="$TARGET/$p"
    fi
  fi
  printf '%s' "$p"
}

# Ensure a path resides under $TARGET and return its relative form
rel_under_target() {
  local abs="$1"
  case "$abs" in
    "$TARGET"/*) printf '%s' "${abs#${TARGET}/}" ;;
    *) return 1 ;;
  esac
}

# Force remove conflicting files/symlinks before applying
force_remove_conflicts() {
  local pkg target_file pkg_file
  for pkg in "${PACKAGES[@]}"; do
    case "$pkg" in
      */*)
        # 嵌套包（如 hosts/VM-0-10-centos）
        local base=${pkg%/*}
        local name=${pkg##*/}
        local pkg_dir="$STOW_DIR/$base/$name"
        ;;
      *)
        # 普通包
        local pkg_dir="$STOW_DIR/$pkg"
        ;;
    esac
    
    if [[ ! -d "$pkg_dir" ]]; then
      log "跳过：包目录不存在 -> $pkg_dir"
      continue
    fi
    
    # Find all files in the package and check for conflicts
    while IFS= read -r -d '' pkg_file; do
      local rel_path="${pkg_file#$pkg_dir/}"
      local target_file="$TARGET/$rel_path"
      if [[ -e "$target_file" || -L "$target_file" ]]; then
        if [[ $YES -eq 1 ]]; then
          log "强制删除冲突文件: $target_file"
          rm -rf "$target_file"
        else
          confirm "删除冲突文件 $target_file ?" || continue
          rm -rf "$target_file"
        fi
      fi
    done < <(find "$pkg_dir" -type f -print0)
  done
}

# Resolve conflicts by prompting override/defer or honoring -y defaults
force_remove_conflicts_by_stow_check() {
  log "检查 stow 冲突并选择 override/defer..."
  local temp_output
  temp_output=$(mktemp)
  
  # Run stow dry-run to detect conflicts
  if run_stow -n -S 2>"$temp_output"; then
    log "没有发现冲突"
    rm -f "$temp_output"
    return 0
  fi
  
  # Parse conflict files from stow error output
  local conflict_files=()
  while IFS= read -r line; do
    if [[ "$line" =~ existing\ target\ is\ not\ owned\ by\ stow:\ (.+) ]]; then
      local file="${BASH_REMATCH[1]}"
      local full_path="$TARGET/$file"
      conflict_files+=("$full_path")
    elif [[ "$line" =~ existing\ target\ is\ stowed\ to\ a\ different\ package:\ ([^[:space:]]+) ]]; then
      local file="${BASH_REMATCH[1]}"
      local full_path="$TARGET/$file"
      conflict_files+=("$full_path")
    elif [[ "$line" =~ cannot\ stow\ .+\ over\ existing\ target\ (.+)\ since\ neither\ a\ link\ nor\ a\ directory ]]; then
      local file="${BASH_REMATCH[1]}"
      local full_path="$TARGET/$file"
      conflict_files+=("$full_path")
    fi
  done < "$temp_output"
  
  rm -f "$temp_output"
  
  if [[ ${#conflict_files[@]} -eq 0 ]]; then
    log "未发现可解析的冲突文件"
    return 0
  fi

  # Helpers
  local action ans _rel _esc _pat
  choose_action() {
    local prompt="$1"
    read -r -p "$prompt [o=override/d=defer/a=adopt/q=quit] (默认 d): " ans || ans=""
    case "$ans" in
      o|O|override|OVERRIDE) action=override ;;
      d|D|defer|DEFER|"")  action=defer    ;;
      a|A|adopt|ADOPT)       action=adopt    ;;
      q|Q|quit|QUIT)         action=quit     ;;
      *)                     action=defer    ;;
    esac
  }
  regex_matches_any() {
    local str="$1"; shift
    local pat
    for pat in "$@"; do
      [[ "$str" =~ $pat ]] && return 0
    done
    return 1
  }

  # Decide override/defer for each conflict
  for file in "${conflict_files[@]}"; do
    _rel="${file#$TARGET/}"
    _esc=$(printf '%s\n' "$_rel" | sed 's/[[\.*^$()+{}|]/\\&/g')
    _pat="^${_esc}\$"
    if [[ $YES -eq 1 ]]; then
      # Non-interactive: if user gave a matching --defer, skip; otherwise remove and override
      if [[ ${#DEFER_PATTERNS[@]} -gt 0 ]] && regex_matches_any "$_rel" "${DEFER_PATTERNS[@]}"; then
        if [[ -d "$file" && ! -L "$file" ]]; then
          log "已匹配 defer(目录)，推迟处理: $_rel"
        else
          log "已匹配 defer(文件)，忽略处理: $_rel"
          IGNORE_PATTERNS+=("$_pat")
        fi
      else
        log "覆盖冲突（删除后重建链接）: $file"
        if [[ $DRY_RUN -eq 1 ]]; then
          log "DRY-RUN: + rm -rf \"$file\""
        else
          rm -rf "$file"
        fi
        OVERRIDE_PATTERNS+=("$_pat")
      fi
      continue
    fi
    choose_action "冲突: $_rel"
    case "$action" in
      override)
        if [[ $DRY_RUN -eq 1 ]]; then
          log "DRY-RUN: + rm -rf \"$file\""
        else
          rm -rf "$file"
        fi
        OVERRIDE_PATTERNS+=("$_pat")
        log "已删除并标记 override: $_rel"
        ;;
      defer)
        if [[ -d "$file" && ! -L "$file" ]]; then
          DEFER_PATTERNS+=("$_pat")
          log "添加 defer(目录) 模式: $_pat"
        else
          IGNORE_PATTERNS+=("$_pat")
          log "添加 ignore(文件) 模式: $_pat"
        fi
        ;;
      adopt)
        # Move existing target from $TARGET into the current package
        # Determine destination package directory (first package in PACKAGES)
        local pkg dst_in_pkg dst_dir
        pkg="${PACKAGES[0]}"
        case "$pkg" in
          */*) dst_dir="$STOW_DIR/${pkg%/*}/${pkg##*/}" ;;
          *)   dst_dir="$STOW_DIR/$pkg" ;;
        esac
        dst_in_pkg="$dst_dir/$_rel"
        if [[ -L "$file" ]]; then
          # Adopting a symlink is ambiguous; prefer override instead
          log "目标为符号链接，采用 override 接管: $_rel"
          if [[ $DRY_RUN -eq 1 ]]; then
            log "DRY-RUN: + rm -rf \"$file\""
          else
            rm -rf "$file"
          fi
          OVERRIDE_PATTERNS+=("$_pat")
          log "已删除并标记 override: $_rel"
        else
          if [[ $DRY_RUN -eq 1 ]]; then
            log "DRY-RUN: + mkdir -p \"$(dirname "$dst_in_pkg")\""
            if [[ -e "$dst_in_pkg" || -L "$dst_in_pkg" ]]; then
              log "DRY-RUN: + rm -rf \"$dst_in_pkg\""
            fi
            log "DRY-RUN: + mv \"$file\" \"$dst_in_pkg\""
          else
            mkdir -p "$(dirname "$dst_in_pkg")"
            if [[ -e "$dst_in_pkg" || -L "$dst_in_pkg" ]]; then
              if [[ $YES -eq 1 ]]; then
                rm -rf "$dst_in_pkg"
              else
                if ! confirm "包内已存在：$dst_in_pkg。是否覆盖？"; then
                  # 用户拒绝覆盖包内文件：回退为忽略该路径，避免后续 stow 再次冲突并中止
                  IGNORE_PATTERNS+=("$_pat")
                  log "已跳过收编并添加 ignore: $_rel"
                  continue
                fi
                rm -rf "$dst_in_pkg"
              fi
            fi
            mv "$file" "$dst_in_pkg"
            log "已收编：$file -> $dst_in_pkg"
          fi
        fi
        ;;
      quit)
        die "已取消"
        ;;
    esac
  done
}


cmd_preview() { ensure_packages; run_stow -n -v -S; }
cmd_apply()   { 
  ensure_packages
  if [[ $FORCE -eq 1 ]]; then
    force_remove_conflicts_by_stow_check
  fi
  
  run_stow -S
}
cmd_unstow()  { ensure_packages; run_stow -D; }
cmd_restow()  { 
  ensure_packages
  if [[ $FORCE -eq 1 ]]; then
    force_remove_conflicts_by_stow_check
  fi
  run_stow -R
}

cmd_auto() {
  # Save originals
  local _orig_use_host=$USE_HOST
  local _orig_yes=$YES
  local _orig_force=$FORCE
  local _orig_host_name=$HOST_NAME
  local -a _orig_packages=("${PACKAGES[@]}")
  local -a _orig_defer=("${DEFER_PATTERNS[@]}")
  local -a _orig_override=("${OVERRIDE_PATTERNS[@]}")
  local -a _orig_ignore=("${IGNORE_PATTERNS[@]}")

  # Step 1: base apply --force -y
  USE_HOST=0; YES=1; FORCE=1; PACKAGES=()
  DEFER_PATTERNS=("${_orig_defer[@]}")
  OVERRIDE_PATTERNS=("${_orig_override[@]}")
  IGNORE_PATTERNS=("${_orig_ignore[@]}")
  local _drflag=""; [[ ${DRY_RUN:-0} -eq 1 ]] && _drflag=" -n"
  log "[auto] apply base (--force -y$_drflag)"
  cmd_apply

  # Step 2: host apply --force -y
  USE_HOST=1; HOST_NAME=${_orig_host_name:-$(default_host)}; PACKAGES=()
  DEFER_PATTERNS=("${_orig_defer[@]}")
  OVERRIDE_PATTERNS=("${_orig_override[@]}")
  IGNORE_PATTERNS=("${_orig_ignore[@]}")
  _drflag=""; [[ ${DRY_RUN:-0} -eq 1 ]] && _drflag=" -n"
  log "[auto] apply --host (--force -y$_drflag)"
  cmd_apply

  # Restore
  USE_HOST=$_orig_use_host
  YES=$_orig_yes
  FORCE=$_orig_force
  HOST_NAME=$_orig_host_name
  PACKAGES=("${_orig_packages[@]}")
  DEFER_PATTERNS=("${_orig_defer[@]}")
  OVERRIDE_PATTERNS=("${_orig_override[@]}")
  IGNORE_PATTERNS=("${_orig_ignore[@]}")
}

cmd_grab() {
  ensure_packages
  # In grab, treat --force as consent to overwrite existing destination under STOW_DIR
  if [[ $FORCE -eq 1 ]]; then YES=1; fi
  if [[ ${#PACKAGES[@]} -gt 1 ]]; then
    die "grab 目前仅支持单个包，请用 -p 指定一个包（当前: ${PACKAGES[*]}）"
  fi
  local pkg="${PACKAGES[0]}"
  if [[ ${#PATHS[@]} -eq 0 ]]; then
    die "grab 需要至少一个要抓取的路径"
  fi
  need_cmd mkdir; need_cmd mv
  local moved_any=0
  for src_in in "${PATHS[@]}"; do
    local abs src rel dst dstdir absp
    abs=$(norm_src "$src_in")
    if [[ ! -e "$abs" ]]; then
      # 智能推断：若传入的是相对路径且当前目录存在该文件，且位于 TARGET 下，则按当前目录解析
      if [[ "$src_in" != /* && "$src_in" != ~* ]]; then
        absp="$PWD/$src_in"
        if [[ -e "$absp" ]]; then
          # 仅当位于 TARGET 下且不在 STOW_DIR 内时才采用 CWD 推断
          if rel=$(rel_under_target "$absp"); then
            case "$absp" in
              "$STOW_DIR"/*) err "跳过：位于 STOW_DIR 内，忽略 -> $absp"; continue ;;
              *) abs="$absp" ;;
            esac
          else
            err "跳过：不在 TARGET 范围内 -> $absp"; continue
          fi
        else
          err "跳过：不存在的路径 -> $abs"; continue
        fi
      else
        err "跳过：不存在的路径 -> $abs"; continue
      fi
    fi
    rel=$(rel_under_target "$abs") || { err "跳过：不在 TARGET 范围内 -> $abs"; continue; }
    dst="$STOW_DIR/$pkg/$rel"
    dstdir=$(dirname "$dst")
    if [[ $DRY_RUN -eq 1 ]]; then
      log "DRY-RUN: + mkdir -p \"$dstdir\""
      if [[ -e "$dst" ]]; then
        log "DRY-RUN: + rm -rf \"$dst\""
      fi
      log "DRY-RUN: + mv \"$abs\" \"$dst\""
    else
      log "+ mkdir -p \"$dstdir\""
      mkdir -p "$dstdir"
      if [[ -e "$dst" ]]; then
        if [[ $YES -eq 1 ]]; then
          log "目标已存在，覆盖：$dst"
          log "+ rm -rf \"$dst\""
          rm -rf "$dst"
        else
          confirm "目标已存在：$dst。是否覆盖？" || { err "已跳过 $abs"; continue; }
          log "+ rm -rf \"$dst\""
          rm -rf "$dst"
        fi
      fi
      log "+ mv \"$abs\" \"$dst\""
      mv "$abs" "$dst"
      moved_any=1
      log "已移动：$abs -> $dst"
    fi
  done
  # After moving, restow the package to create symlinks
  if [[ $DRY_RUN -eq 1 ]]; then
    # 构建等效的 stow 选项并打印将执行的命令（均为模拟模式）
    build_opts
    # 确保预览输出包含 -n（如果未通过 -n 指定，build_opts 不会注入；此处手动保证）
    case " ${STOW_OPTS[*]} " in
      *" -n "*) : ;;
      *) STOW_OPTS=( -n "${STOW_OPTS[@]}" ) ;;
    esac
    log "DRY-RUN: + stow ${STOW_OPTS[*]} -R -- ${PACKAGES[*]}"
    log "DRY-RUN: + stow ${STOW_OPTS[*]} -S -- ${PACKAGES[*]}"
  else
    # Prefer restow; if it fails (e.g. first time, nothing to restow), fallback to apply (-S)
    if run_stow -R; then
      :
    else
      log "restow 失败，尝试 apply (-S)"
      run_stow -S
    fi
  fi
}

cmd_putback() {
  ensure_packages
  if [[ ${#PACKAGES[@]} -gt 1 ]]; then
    die "putback 目前仅支持单个包，请用 -p 指定一个包（当前: ${PACKAGES[*]}）"
  fi
  local pkg="${PACKAGES[0]}"
  if [[ ${#PATHS[@]} -eq 0 ]]; then
    die "putback 需要至少一个路径：可传 TARGET 下路径、包内相对路径，或指向包内的符号链接"
  fi
  need_cmd mkdir; need_cmd cp; need_cmd readlink
  local copied_any=0
  for arg in "${PATHS[@]}"; do
    local abs rel src dst dstdir orig rp pkg_root absp
    orig="$arg"
    abs=$(norm_src "$orig")
    pkg_root="$STOW_DIR/$pkg"
    # 优先：TARGET 下路径
    if rel=$(rel_under_target "$abs"); then
      # 若包内不存在该相对路径，且当前目录在包内，尝试用包内相对路径替代
      if [[ ! -e "$pkg_root/$rel" && ! -L "$pkg_root/$rel" ]]; then
        absp="$PWD/$orig"
        if [[ "$PWD" == "$pkg_root"* && ( -e "$absp" || -L "$absp" ) && "$absp" == "$pkg_root"/* ]]; then
          rel="${absp#"$pkg_root/"}"
        fi
      fi
    else
      # 若传入相对路径，尝试视为包内相对路径
      if [[ "$orig" != /* && "$orig" != ~* && -e "$pkg_root/$orig" ]]; then
        rel="$orig"
      else
        # 若当前目录位于包内，且参数在该子目录下存在，则推导相对包根路径
        absp="$PWD/$orig"
        if [[ "$PWD" == "$pkg_root"* && ( -e "$absp" || -L "$absp" ) && "$absp" == "$pkg_root"/* ]]; then
          rel="${absp#"$pkg_root/"}"
        else
          # 若是符号链接且指向包内，反解相对路径
          if [[ -L "$abs" ]]; then
            rp=$(readlink -f "$abs" 2>/dev/null || true)
            if [[ -n "$rp" && "$rp" == "$pkg_root"/* ]]; then
              rel="${rp#"$pkg_root/"}"
            else
              err "跳过：无法解析到包内路径 -> $orig"
              continue
            fi
          else
            err "跳过：不在 TARGET 且非包内相对路径/有效符号链接 -> $orig"
            continue
          fi
        fi
      fi
    fi
    src="$STOW_DIR/$pkg/$rel"
    dst="$TARGET/$rel"
    dstdir=$(dirname "$dst")
    # Ensure source exists
    if [[ ! -e "$src" && ! -L "$src" ]]; then
      err "跳过：包内不存在 -> $src"
      continue
    fi
    # Policy: if destination exists and is not a symlink, skip unless --allow-non-symlink
    if [[ -e "$dst" || -L "$dst" ]]; then
      if [[ ! -L "$dst" ]]; then
        if [[ $ALLOW_NON_SYMLINK -eq 0 ]]; then
          # If destination resolves into STOW_DIR (parent dir is a repo symlink), warn explicitly
          local dst_real
          dst_real=$(readlink -f "$dst" 2>/dev/null || printf '%s' "$dst")
          case "$dst_real" in
            "$STOW_DIR"/*)
              err "安全保护：目标真实路径落在 STOW_DIR 内（父目录是仓库链接），已跳过 -> $dst_real" ;;
            *)
              err "安全策略：目标存在且不是符号链接，已跳过（可用 --allow-non-symlink 覆盖） -> $dst" ;;
          esac
          continue
        fi
      fi
    fi
    # When destination is a symlink, it's safe to replace it (won't follow into repo)
    if [[ $DRY_RUN -eq 1 ]]; then
      log "DRY-RUN: + mkdir -p \"$dstdir\""
      if [[ -e "$dst" || -L "$dst" ]]; then
        log "DRY-RUN: + rm -rf \"$dst\""
      fi
      log "DRY-RUN: + cp -a \"$src\" \"$dst\""
    else
      log "+ mkdir -p \"$dstdir\""; mkdir -p "$dstdir"
      # Double-check source exists before touching destination
      if [[ ! -e "$src" && ! -L "$src" ]]; then
        err "跳过：包内不存在 -> $src"; continue
      fi
      if [[ -e "$dst" || -L "$dst" ]]; then
        if [[ $YES -eq 1 ]]; then
          if [[ -L "$dst" ]]; then
            log "+ unlink \"$dst\""; unlink "$dst" || rm -f "$dst"
          elif [[ -f "$dst" ]]; then
            : # keep file, we'll overwrite via cp
          elif [[ -d "$dst" ]]; then
            log "+ rm -rf \"$dst\""; rm -rf "$dst"
          else
            log "+ rm -f \"$dst\""; rm -f "$dst"
          fi
        else
          confirm "目标已存在：$dst。是否覆盖？" || { err "已跳过 $dst"; continue; }
          if [[ -L "$dst" ]]; then
            log "+ unlink \"$dst\""; unlink "$dst" || rm -f "$dst"
          elif [[ -f "$dst" ]]; then
            :
          elif [[ -d "$dst" ]]; then
            log "+ rm -rf \"$dst\""; rm -rf "$dst"
          else
            log "+ rm -f \"$dst\""; rm -f "$dst"
          fi
        fi
      fi
      # Prefer cp with --remove-destination when available to avoid following symlinks
      if cp --help 2>/dev/null | grep -q -- "remove-destination"; then
        log "+ cp -a --remove-destination \"$src\" \"$dst\""; cp -a --remove-destination "$src" "$dst"
      else
        log "+ cp -a \"$src\" \"$dst\""; cp -a "$src" "$dst"
      fi
      copied_any=1
      log "已复制：$src -> $dst"
    fi
  done
  if [[ $copied_any -eq 1 && $DRY_RUN -eq 0 ]]; then
    log "putback 完成：共处理 ${#PATHS[@]} 项"
  fi
}

cmd_adopt() {
  ensure_packages
  if [[ $DRY_RUN -eq 1 ]]; then
    log "adopt 以干跑模式执行"
    run_stow -S --adopt
    return 0
  fi
  local prompt
  if [[ $DO_RESTORE -eq 1 ]]; then
    prompt="将以覆盖式部署（--adopt + git restore .）覆盖工作区改动。确认继续吗？"
  else
    prompt="将以收编部署（--adopt，仅收编不恢复），不会自动覆盖仓库改动。确认继续吗？"
  fi
  confirm "$prompt" || die "已取消"
  run_stow -S --adopt
  if [[ $DO_RESTORE -eq 1 ]]; then
    for pkg in "${PACKAGES[@]}"; do
      local repo="$STOW_DIR/$pkg"
      if git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log "+ git -C \"$repo\" restore ."
        git -C "$repo" restore .
      else
        log "跳过 git restore：$repo 不是 git 仓库"
      fi
    done
  else
    log "已跳过 git restore ."
  fi
}

cmd_list() {
  [[ -d "$STOW_DIR" ]] || die "STOW_DIR 不存在: $STOW_DIR"
  ensure_global_ignore_file
  load_global_ignore
  local -a top_dirs=()
  while IFS= read -r name; do
    top_dirs+=("$name")
  done < <(find "$STOW_DIR" -mindepth 1 -maxdepth 1 -type d -prune -exec basename {} \; | sort)

  local name
  for name in "${top_dirs[@]}"; do
    if pkg_ignored "$name"; then
      continue
    fi
    case "$name" in
      hosts|mods)
        echo "$name/"
        local dir="$STOW_DIR/$name"
        if [[ -d "$dir" ]]; then
          while IFS= read -r sub; do
            local rel="$name/$sub"
            if pkg_ignored "$rel"; then
              continue
            fi
            echo "  $sub"
          done < <(find "$dir" -mindepth 1 -maxdepth 1 -type d -prune -exec basename {} \; | sort)
        fi
        ;;
      *)
        echo "$name"
        ;;
    esac
  done
}

main() {
  parse_args "$@"

  if [[ $USE_HOST -eq 1 ]]; then
    HOST_NAME=${HOST_NAME:-$(default_host)}
    HOST_PACKAGE="hosts/$HOST_NAME"
  fi

  # Map POSITIONALS depending on command
  if [[ "${CMD:-}" == "grab" || "${CMD:-}" == "putback" ]]; then
    PATHS=("${POSITIONALS[@]}")
  else
    if [[ ${#PACKAGES[@]} -eq 0 && ${#POSITIONALS[@]} -gt 0 ]]; then
      PACKAGES=("${POSITIONALS[@]}")
    fi
  fi
  case "${CMD:-}" in
    preview) cmd_preview ;;
    apply)   cmd_apply   ;;
    auto)    cmd_auto    ;;
    adopt)   cmd_adopt   ;;
    grab)    cmd_grab    ;;
    putback) cmd_putback ;;
    unstow)  cmd_unstow  ;;
    restow)  cmd_restow  ;;
    list)    cmd_list    ;;
    help|"") usage ;;
    *) err "未知命令: $CMD"; usage; exit 2 ;;
  esac
}

main "$@"
