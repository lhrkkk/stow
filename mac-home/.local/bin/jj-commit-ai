#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'USAGE'
Usage: jj-commit-ai [options] [-- <jj commit args>]

生成提交信息并可选直接 `jj commit`。

Options:
  --model NAME         指定 Codex 模型（默认：$JJ_COMMIT_AI_MODEL 或 gpt-5）
  --max-bytes N        发送给模型的 diff 最大字节数（默认：$JJ_COMMIT_AI_MAX_BYTES 或 120000）
  --preview            仅打印生成结果，不提交
  --commit             直接提交（不再询问）
  --yes                等同 --commit
  --show-prompt        打印发送给模型的完整提示词
  --extra TEXT         追加一段实时指令到提示词
  --lang CODE          指定输出语言，如 zh、en（默认：zh）
  --chinese            快捷方式，等同 --lang zh
  --wrap-subject STYLE 自定义标题包装（例如 brackets、cn-brackets；默认：cn-brackets）
  --bracket-title      快捷方式，标题使用半角方括号[]
  --bracket-title-cn   快捷方式，标题使用全角方括号【】
  --reasoning-effort, -r V 设置 Codex 推理强度（默认 minimal；可选：minimal/low/medium/high）
  --api NAME           指定使用的 API 后端 (默认: codex，可选: gemini)
  -h, --help           查看帮助

环境变量：
  GEMINI_API_KEY            使用 gemini 后端时的 API Key
  JJ_COMMIT_AI_BACKEND      默认的 API 后端（默认 codex，可选 gemini）
  JJ_COMMIT_AI_MODEL        默认模型名称
  JJ_COMMIT_AI_MAX_BYTES    diff 上限
  JJ_COMMIT_AI_EXTRA_PROMPT 额外固定提示词
  JJ_COMMIT_AI_COMMAND      调用命令（默认：codex）
  JJ_COMMIT_AI_CLI_ARGS     额外传给 Codex CLI 的参数（以空格分隔；默认保持 Codex 自身策略）
  JJ_COMMIT_AI_DEBUG        非空时打印调试信息
  JJ_COMMIT_AI_LANG        默认输出语言（如 zh、en；默认 zh）
  JJ_COMMIT_AI_WRAP_SUBJECT 标题包装样式（默认 cn-brackets）
  JJ_COMMIT_AI_KEEP_HISTORY 非空时保留 Codex CLI 历史目录（默认使用隔离目录）
  JJ_COMMIT_AI_CODEX_HOME   自定义隔离目录根路径（默认：$HOME/.codex/jj-commit-ai）
  JJ_COMMIT_AI_CODEX_FALLBACK 指定无权限写入时的备选目录（默认使用 $TMPDIR/jj-commit-ai）
USAGE
}

MODEL=${JJ_COMMIT_AI_MODEL:-gpt-5}
MAX_BYTES=${JJ_COMMIT_AI_MAX_BYTES:-120000}
EXTRA_PROMPT=${JJ_COMMIT_AI_EXTRA_PROMPT:-}
CLI_COMMAND=${JJ_COMMIT_AI_COMMAND:-codex}
# 兼容误设别名：若显式设为 "dx"，视为 codex
if [[ "$CLI_COMMAND" == "dx" ]]; then
  CLI_COMMAND="codex"
fi
DEFAULT_CLI_ARGS=""
LANG_PREF=${JJ_COMMIT_AI_LANG:-zh}
SUBJECT_STYLE=${JJ_COMMIT_AI_WRAP_SUBJECT:-cn-brackets}
REASONING_EFFORT=${JJ_COMMIT_AI_REASONING_EFFORT:-minimal}
DEBUG=${JJ_COMMIT_AI_DEBUG:-}
API_BACKEND=${JJ_COMMIT_AI_BACKEND:-codex}

AUTO_COMMIT=0
PREVIEW_ONLY=0
ASSUME_YES=0
SHOW_PROMPT=0
EXTRA_RUNTIME_PROMPT=""
JJ_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --model) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --model 需要参数" >&2; exit 2; }
      MODEL="$2"
      shift 2
      ;; 
    --max-bytes) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --max-bytes 需要参数" >&2; exit 2; }
      if ! [[ "$2" =~ ^[0-9]+$ ]]; then
        echo "jj-commit-ai: --max-bytes 必须为整数" >&2
        exit 2
      fi
      MAX_BYTES="$2"
      shift 2
      ;; 
    --preview|--dry-run|--message-only) 
      PREVIEW_ONLY=1
      shift
      ;; 
    --commit) 
      AUTO_COMMIT=1
      shift
      ;; 
    --yes|-y) 
      AUTO_COMMIT=1
      ASSUME_YES=1
      shift
      ;; 
    --show-prompt) 
      SHOW_PROMPT=1
      shift
      ;; 
    --extra) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --extra 需要参数" >&2; exit 2; }
      EXTRA_RUNTIME_PROMPT="$2"
      shift 2
      ;; 
    --api) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --api 需要参数" >&2; exit 2; }
      API_BACKEND="$2"
      shift 2
      ;; 
    --lang) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --lang 需要参数" >&2; exit 2; }
      LANG_PREF="$2"
      shift 2
      ;; 
    --chinese) 
      LANG_PREF="zh"
      shift
      ;; 
    --wrap-subject) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: --wrap-subject 需要参数" >&2; exit 2; }
      SUBJECT_STYLE="$2"
      shift 2
      ;; 
    --bracket-title) 
      SUBJECT_STYLE="brackets"
      shift
      ;; 
    --bracket-title-cn) 
      SUBJECT_STYLE="cn-brackets"
      shift
      ;; 
    -r|--reason|--reasoning|--reasoning-effort) 
      [[ $# -ge 2 ]] || { echo "jj-commit-ai: $1 需要参数" >&2; exit 2; }
      REASONING_EFFORT="$2"
      shift 2
      ;; 
    -h|--help) 
      show_help
      exit 0
      ;; 
    --) 
      shift
      JJ_ARGS=("${@}")
      break
      ;; 
    *)
      JJ_ARGS+=("$1")
      shift
      ;; 
  esac
done

# 尝试找到 codex CLI（仅在使用 codex 后端时需要）
if [[ "$API_BACKEND" == "codex" ]]; then
  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    if [[ -d "$HOME/.local/share/mise/shims" ]]; then
      PATH="$HOME/.local/share/mise/shims:$PATH"
    fi
  fi

  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    if [[ -x "/opt/homebrew/bin/$CLI_COMMAND" ]]; then
      PATH="/opt/homebrew/bin:$PATH"
    elif [[ -x "/home/linuxbrew/.linuxbrew/bin/$CLI_COMMAND" ]]; then
      PATH="/home/linuxbrew/.linuxbrew/bin:$PATH"
    elif [[ -x "$HOME/.local/bin/$CLI_COMMAND" ]]; then
      PATH="$HOME/.local/bin:$PATH"
    fi
  fi

  if ! command -v "$CLI_COMMAND" >/dev/null 2>&1; then
    echo "jj-commit-ai: 找不到 $CLI_COMMAND，可设置 JJ_COMMIT_AI_COMMAND 自定义" >&2
    exit 127
  fi
fi

STATUS_OUTPUT=$(jj status --color=never 2>/dev/null || true)
DIFF_STAT=$(jj diff --stat --color=never 2>/dev/null || true)
DIFF_OUTPUT=$(jj diff --git --color=never 2>/dev/null || true)

trimmed_diff=$(printf '%s' "$DIFF_OUTPUT" | tr -d '\r\n\t ')
trimmed_stat=$(printf '%s' "$DIFF_STAT" | tr -d '\r\n\t ')
if [[ -z "$trimmed_diff" && -z "$trimmed_stat" ]]; then
  echo "jj-commit-ai: 没有检测到改动，退出" >&2
  exit 1
fi

TRUNCATED_FLAG=""
if (( MAX_BYTES > 0 )); then
  DIFF_BYTES=$(printf '%s' "$DIFF_OUTPUT" | wc -c | tr -d ' ')
  if (( DIFF_BYTES > MAX_BYTES )); then
    DIFF_OUTPUT=$(printf '%s' "$DIFF_OUTPUT" | head -c "$MAX_BYTES")
    TRUNCATED_FLAG=$'\n\n[Diff truncated to '
    TRUNCATED_FLAG+="$MAX_BYTES"
    TRUNCATED_FLAG+=$' bytes for AI prompt.]'
  fi
fi

BASE_PROMPT_EN=$'You are an expert developer creating high-quality commit messages for the Jujutsu (jj) VCS.\nGuidelines:\n- Provide a concise subject line (<= 72 characters).\n- Make the subject specific and concrete; prefer user-visible behavior or feature area over file/module names. Avoid listing files or internal helper identifiers (unless they are user-facing commands). Avoid vague words like update, improve, fix.\n- Pack as many key points as feasible into the subject using compact separators (/, -, comma), while staying within 72 characters; if not possible, include the top 2–3 most important points.\n- Output only the commit message, with the subject on the first line; no preamble, meta text, disclaimers, or headings; do not write lines like "Here is...", "Drafting...", or "in Chinese".\n- Add at most 3 short bullets after a blank line; each bullet should be a single clause starting with a verb, avoid long chains (and/then/;), <= 80 characters.\n- No Markdown formatting (no bold/italics/headings) and no code fences or surrounding quotes.\n- Prioritise the most impactful changes if the diff is long.\n- Use sentence case for the subject.\n- Example (good): 【Unify source label and keep separators】; Example (bad): 【jj-commit-ai】.\n'
BASE_PROMPT="$BASE_PROMPT_EN"

if [[ -n "$LANG_PREF" ]]; then
  case "$LANG_PREF" in
    zh|zh-CN|zh-cn|cn|中文|简体中文) 
      BASE_PROMPT=$'你是一名资深开发者，需要为 Jujutsu (jj) 版本控制系统撰写高质量的提交信息。\n规范：\n- 提交标题不超过 72 个字符，使用简洁的陈述语气。\n- 标题需具体明确：优先描述“用户可见的行为/影响或功能区域”；除非是用户直接使用的命令名，否则不要把文件/模块名（尤其是 foo/bar 形式）当作标题主体；避免“更新/优化/修复”等过于抽象的词。\n- 标题尽可能涵盖本次修改的多个重点；可用“/、-、、”等紧凑分隔符串联，整体不超过 72 字符；若无法全部容纳，请保留 2–3 个最重要要点。\n- 只输出提交信息本身：首行直接给出标题；不要输出任何引导语/说明/免责声明/小标题；不要出现“以下是…/Here is/草拟/正在用中文”等字样。\n- 标题下方空一行后列出要点；最多 3 条，每条使用动宾短语且只包含一项结果，不要长句或多个“并且/以及”，长度不超过 80 字符。\n- 不要使用 Markdown 强调/标题/代码块（如 **、#、```），也不要在外层加引号。\n- 若改动较多，请突出最重要的影响。\n- 所有内容必须使用简体中文撰写；如模型生成了非中文，请立即用简体中文重新表述。\n- 示例（好的）：【统一来源标签并保留分隔线】；示例（不佳）：【jj-commit-ai】。\n'
      ;; 
    *) 
      BASE_PROMPT="${BASE_PROMPT_EN}Please write the subject line and bullet list in ${LANG_PREF}.\n"
      ;; 
  esac
fi

if [[ -n "$SUBJECT_STYLE" ]]; then
  case "$SUBJECT_STYLE" in
    brackets) 
      if [[ -n "$LANG_PREF" ]]; then
        case "$LANG_PREF" in
          zh|zh-CN|zh-cn|cn|中文|简体中文) 
            BASE_PROMPT+=$'\n请将提交标题整体放在半角方括号内，例如：[新增功能]。\n'
            ;; 
          *)
            BASE_PROMPT+=$'\nWrap the subject line in square brackets, e.g. [Subject Title].\n'
            ;; 
        esac
      else
        BASE_PROMPT+=$'\nWrap the subject line in square brackets, e.g. [Subject Title].\n'
      fi
      ;; 
    cn-brackets) 
      if [[ -n "$LANG_PREF" && $LANG_PREF =~ ^(zh|zh-CN|zh-cn|cn|中文|简体中文)$ ]]; then
        BASE_PROMPT+=$'\n请将提交标题整体放在全角方括号内，例如：【新增功能】。\n'
      else
        BASE_PROMPT+=$'\nWrap the subject line in full-width brackets, e.g. 【Subject Title】.\n'
      fi
      ;; 
    *)
      ;; 
  esac
fi

if [[ -n "$EXTRA_PROMPT" ]]; then
  BASE_PROMPT+=$'\nAdditional preferences:\n'
  BASE_PROMPT+="$EXTRA_PROMPT"
  BASE_PROMPT+=$'\n'
fi

if [[ -n "$EXTRA_RUNTIME_PROMPT" ]]; then
  BASE_PROMPT+=$'\nReal-time instructions:\n'
  BASE_PROMPT+="$EXTRA_RUNTIME_PROMPT"
  BASE_PROMPT+=$'\n'
fi

PROMPT_BODY=$'\nRepository status (jj status):\n'
PROMPT_BODY+="$STATUS_OUTPUT"
PROMPT_BODY+=$'\n\nDiff summary (jj diff --stat):\n'
PROMPT_BODY+="$DIFF_STAT"
PROMPT_BODY+=$'\n\nDiff (git format):\n'
PROMPT_BODY+="$DIFF_OUTPUT"
PROMPT_BODY+="$TRUNCATED_FLAG"

FINAL_PROMPT="$BASE_PROMPT$PROMPT_BODY"

if (( SHOW_PROMPT )); then
  echo "===== AI PROMPT BEGIN ===="
  printf '%s\n' "$FINAL_PROMPT"
  echo "===== AI PROMPT END ===="
fi

COMMIT_MESSAGE=""
USING_FALLBACK=0
CLI_STATUS=0
MESSAGE_SOURCE=""

if [[ "$API_BACKEND" == "gemini" ]]; then
    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        echo "jj-commit-ai: 使用 gemini 后端时，必须设置 GEMINI_API_KEY 环境变量" >&2
        exit 1
    fi

    set +e
    COMMIT_MESSAGE=$(JJ_COMMIT_AI_PROMPT="$FINAL_PROMPT" \
                     GEMINI_API_KEY="${GEMINI_API_KEY}" \
                     python3 - <<'PY_GEMINI'
import os
import sys
import json
import urllib.request

def main():
    prompt = os.environ.get('JJ_COMMIT_AI_PROMPT')
    api_key = os.environ.get('GEMINI_API_KEY')
    model = os.environ.get('JJ_COMMIT_AI_GEMINI_MODEL', 'gemini-1.5-flash-latest')

    if not prompt:
        print("Error: Prompt is empty.", file=sys.stderr)
        sys.exit(1)
    if not api_key:
        print("Error: GEMINI_API_KEY is not set.", file=sys.stderr)
        sys.exit(1)

    url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}"
    headers = {'Content-Type': 'application/json'}
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": 0.4,
            "topK": 32,
            "topP": 1,
            "maxOutputTokens": 4096,
            "stopSequences": []
        },
        "safetySettings": [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
        ]
    }

    req = urllib.request.Request(url, data=json.dumps(data).encode('utf-8'), headers=headers)
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status == 200:
                response_body = json.loads(response.read().decode('utf-8'))
                candidates = response_body.get('candidates', [])
                if candidates:
                    content = candidates[0].get('content', {})
                    parts = content.get('parts', [])
                    if parts:
                        message = parts[0].get('text', '')
                        def sanitize(msg: str) -> str:
                            lines = []
                            for raw in (msg or "").splitlines():
                                s = raw.strip()
                                if not s:
                                    lines.append("")
                                    continue
                                low = s.lower()
                                meta_kw = ("draft", "drafting", "compose", "composing", "write", "writing", "here is", "in chinese")
                                if ((s.startswith("**") and s.endswith("**")) or s.startswith("#")) and any(k in low for k in ("commit", "message", "提交", "信息", "chinese", "中文")):
                                    continue
                                if any(k in low for k in meta_kw) and ("commit" in low or "message" in low or "提交" in s or "信息" in s):
                                    continue
                                lines.append(s)
                            while lines and not lines[0]:
                                lines.pop(0)
                            while lines and not lines[-1]:
                                lines.pop()
                            if len(lines) > 1 and lines[1] != "":
                                lines.insert(1, "")
                            return "\n".join(lines).strip()
                        print(sanitize(message))
                    else:
                        print(f"Error: Gemini API response is missing 'parts'. Full response: {response_body}", file=sys.stderr)
                        sys.exit(1)
                else:
                    print(f"Error: Gemini API response has no candidates. Full response: {response_body}", file=sys.stderr)
                    sys.exit(1)
            else:
                error_body = response.read().decode('utf-8')
                print(f"Error: Gemini API request failed with status {response.status}: {error_body}", file=sys.stderr)
                sys.exit(1)
    except urllib.error.URLError as e:
        print(f"Error: Failed to reach Gemini API: {e.reason}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
PY_GEMINI
    )
    CLI_STATUS=$?
    set -e
    if (( CLI_STATUS == 0 )); then
      MESSAGE_SOURCE="gemini"
      [[ -z "$COMMIT_MESSAGE" ]] && CLI_STATUS=1
    fi

elif [[ "$API_BACKEND" == "codex" ]]; then
    KEEP_HISTORY=${JJ_COMMIT_AI_KEEP_HISTORY:-}
    SOURCE_CODEX_HOME=${CODEX_HOME:-$HOME/.codex}
    CUSTOM_CODEX_HOME=${JJ_COMMIT_AI_CODEX_HOME:-$SOURCE_CODEX_HOME/jj-commit-ai}
    USE_ISOLATED_CODEX_HOME=0

    if [[ -z "$KEEP_HISTORY" && -z "${CODEX_HOME+x}" ]]; then
      USE_ISOLATED_CODEX_HOME=1
      CODEX_ENV_HOME="$CUSTOM_CODEX_HOME"
      if ! mkdir -p "$CODEX_ENV_HOME" 2>/dev/null; then
        FALLBACK_CODEX_HOME=${JJ_COMMIT_AI_CODEX_FALLBACK:-${TMPDIR:-/tmp}/jj-commit-ai}
        if ! mkdir -p "$FALLBACK_CODEX_HOME" 2>/dev/null; then
          FALLBACK_CODEX_HOME=$(mktemp -d "${TMPDIR:-/tmp}/jj-commit-ai-XXXXXX" 2>/dev/null || true)
        fi
        if [[ -z "$FALLBACK_CODEX_HOME" || ! -d "$FALLBACK_CODEX_HOME" ]]; then
          echo "jj-commit-ai: 无法创建 Codex 缓存目录" >&2
          exit 1
        fi
        CODEX_ENV_HOME="$FALLBACK_CODEX_HOME"
        [[ -n "$DEBUG" ]] && echo "[jj-commit-ai] 回退使用目录: $CODEX_ENV_HOME" >&2
      fi
      if [[ -d "$SOURCE_CODEX_HOME" ]]; then
        for file in config.toml auth.json internal_storage.json; do
          if [[ -e "$SOURCE_CODEX_HOME/$file" && ! -e "$CODEX_ENV_HOME/$file" ]]; then
            cp -p "$SOURCE_CODEX_HOME/$file" "$CODEX_ENV_HOME/$file" 2>/dev/null || true
          fi
        done
        if [[ -d "$SOURCE_CODEX_HOME/sessions" && ! -d "$CODEX_ENV_HOME/sessions" ]]; then
          mkdir -p "$CODEX_ENV_HOME/sessions"
          cp -Rp "$SOURCE_CODEX_HOME/sessions/." "$CODEX_ENV_HOME/sessions/" 2>/dev/null || true
        fi
      fi
      rm -f "$CODEX_ENV_HOME/history.jsonl" 2>/dev/null || true
    else
      CODEX_ENV_HOME="$SOURCE_CODEX_HOME"
    fi

    TMP_STDOUT=$(mktemp "${TMPDIR:-/tmp}/jj-codex-stdout-XXXXXX")
    TMP_OUTPUT=$(mktemp "${TMPDIR:-/tmp}/jj-codex-output-XXXXXX")
    MSG_FILE=""
    cleanup() {
      [[ -n "$TMP_STDOUT" && -f "$TMP_STDOUT" ]] && rm -f "$TMP_STDOUT"
      [[ -n "$TMP_OUTPUT" && -f "$TMP_OUTPUT" ]] && rm -f "$TMP_OUTPUT"
      [[ -n "$MSG_FILE" && -f "$MSG_FILE" ]] && rm -f "$MSG_FILE"
    }
    trap cleanup EXIT

    CLI_ARGS=("$CLI_COMMAND" "exec" "--skip-git-repo-check" "--output-last-message" "$TMP_OUTPUT")
    [[ -n "$MODEL" ]] && CLI_ARGS+=("--model" "$MODEL")
    if [[ -n "$REASONING_EFFORT" ]]; then
      CLI_ARGS+=("-c" "model_reasoning_effort=\"$REASONING_EFFORT\"")
    fi
    CLI_ARGS+=("--json")

    if [[ -n "${JJ_COMMIT_AI_CLI_ARGS:-}" ]]; then
      # shellcheck disable=SC2206
      EXTRA_CLI_ARGS=(${JJ_COMMIT_AI_CLI_ARGS})
      CLI_ARGS+=("${EXTRA_CLI_ARGS[@]}")
    elif [[ -n "$DEFAULT_CLI_ARGS" ]]; then
      # shellcheck disable=SC2206
      EXTRA_CLI_ARGS=(${DEFAULT_CLI_ARGS})
      CLI_ARGS+=("${EXTRA_CLI_ARGS[@]}")
    fi

    [[ -n "$DEBUG" ]] && {
      echo "[jj-commit-ai] 调用命令: ${CLI_ARGS[*]}" >&2
      if (( USE_ISOLATED_CODEX_HOME )); then
        echo "[jj-commit-ai] 使用隔离 CODEX_HOME: $CODEX_ENV_HOME" >&2
      fi
    }

    set +e
    if (( USE_ISOLATED_CODEX_HOME )); then
      CODEX_HOME="$CODEX_ENV_HOME" "${CLI_ARGS[@]}" "$FINAL_PROMPT" >"$TMP_STDOUT" 2>&1
    else
      "${CLI_ARGS[@]}" "$FINAL_PROMPT" >"$TMP_STDOUT" 2>&1
    fi
    CLI_STATUS=$?
    set -e

    if (( USE_ISOLATED_CODEX_HOME )); then
      rm -f "$CODEX_ENV_HOME/history.jsonl" 2>/dev/null || true
    fi

    if (( CLI_STATUS == 0 )); then
        [[ -n "$DEBUG" ]] && {
          echo "[jj-commit-ai] codex stdout:" >&2
          cat "$TMP_STDOUT" >&2
          echo "[jj-commit-ai] codex last message file:" >&2
          cat "$TMP_OUTPUT" >&2 || true
        }

        export JJ_COMMIT_AI_RESPONSE_PATH="$TMP_OUTPUT"
        export JJ_COMMIT_AI_STDOUT_PATH="$TMP_STDOUT"

        COMMIT_MESSAGE=$(python3 - <<'PY'
import json
import os
import re

ANSI_RE = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
JSON_DECODER = json.JSONDecoder()


def read_text(path: str) -> str:
    with open(path, 'r', encoding='utf-8', errors='replace') as fh:
        return fh.read()


def clean(text: str) -> str:
    text = text.replace('\r', '\n')
    text = ANSI_RE.sub('', text)
    lines = []
    for raw in text.splitlines():
        stripped = raw.strip()
        if not stripped:
            continue
        if stripped.startswith('[') and ']' in stripped and stripped[1:5].isdigit():
            continue
        if stripped.startswith('--'):
            continue
        if stripped.startswith('{') and '"_context_window"' in stripped:
            continue
        if stripped.startswith('{') and '"provider"' in stripped and '"model"' in stripped:
            continue
        lines.append(stripped)
    # 保留并规范化空行：首行与正文之间至少一行空行
    while lines and not lines[0]:
        lines.pop(0)
    while lines and not lines[-1]:
        lines.pop()
    if len(lines) > 1 and lines[1] != '':
        lines.insert(1, '')
    return '\n'.join(lines).strip()


def from_struct(obj):
    if isinstance(obj, str):
        return clean(obj)
    if isinstance(obj, dict):
        if 'msg' in obj:
            msg = obj['msg']
            if isinstance(msg, dict):
                msg_type = msg.get('type')
                if msg_type and msg_type != 'agent_message':
                    return ''
            cand = from_struct(msg)
            if cand:
                return cand
        event = obj.get('event')
        if event in {'info', 'status', 'log', 'debug', 'warning', 'progress'}:
            for key in ('data', 'content', 'text', 'output', 'result', 'response', 'value', 'messages'):
                if key in obj and key != 'message':
                    cand = from_struct(obj[key])
                    if cand:
                        return cand
            return ''
        if obj.get('role') == 'assistant':
            cand = from_struct(obj.get('content'))
            if cand:
                return cand
        for key in ('content', 'text', 'message', 'output', 'result', 'response', 'value', 'data', 'messages'):
            if key in obj:
                cand = from_struct(obj[key])
                if cand:
                    return cand
        return ''
    if isinstance(obj, (list, tuple)):
        for item in obj:
            cand = from_struct(item)
            if cand:
                return cand
    return ''


def iter_json_stream(text: str):
    idx = 0
    length = len(text)
    while idx < length:
        while idx < length and text[idx].isspace():
            idx += 1
        if idx >= length:
            break
        try:
            obj, end = JSON_DECODER.raw_decode(text, idx)
        except json.JSONDecodeError:
            next_brace = text.find('{', idx + 1)
            next_bracket = text.find('[', idx + 1)
            candidates = [pos for pos in (next_brace, next_bracket) if pos != -1]
            if candidates:
                idx = min(candidates)
            else:
                idx += 1
            continue
        yield obj
        idx = end


def parse_json_blob(text: str) -> str:
    try:
        data = json.loads(text)
    except Exception:
        data = None
    if data is not None:
        cand = from_struct(data)
        if cand:
            return cand
    for obj in iter_json_stream(text):
        cand = from_struct(obj)
        if cand:
            return cand
    return ''


def parse_json_lines(text: str) -> str:
    for line in reversed(text.splitlines()):
        line = line.strip()
        if not line:
            continue
        try:
            data = json.loads(line)
        except Exception:
            continue
        cand = from_struct(data)
        if cand:
            return cand
    return ''


def strip_meta_blocks(message: str) -> str:
    if not message:
        return message
    def is_meta_line(s: str) -> bool:
        low = s.lower().strip()
        if not low:
            return False
        if (s.startswith('**') and s.endswith('**')) or s.startswith('#'):
            if any(k in low for k in ('commit', 'message', '提交', '信息', 'chinese', '中文')):
                return True
        meta_kw = ('draft', 'drafting', 'compose', 'composing', 'write', 'writing', 'here is', 'in chinese', '以下是', '草拟', '正在用中文', '用中文')
        if any(k in low for k in meta_kw) and any(k in low for k in ('commit', 'message', '提交', '信息')):
            return True
        if low.startswith('title:') or low.startswith('subject:'):
            return True
        return False

    lines = []
    for raw in message.splitlines():
        stripped = raw.strip()
        if not stripped:
            lines.append('')
            continue
        if stripped.startswith('{') and ':' in stripped:
            continue
        if stripped.startswith('[') and ':' in stripped:
            continue
        if stripped.startswith('"') and ':' in stripped:
            continue
        if is_meta_line(stripped):
            continue
        lines.append(stripped)
    while lines and not lines[0]:
        lines.pop(0)
    while lines and not lines[-1]:
        lines.pop()
    return '\n'.join(lines).strip()


message = ''
response_path = os.environ.get('JJ_COMMIT_AI_RESPONSE_PATH')
stdout_path = os.environ.get('JJ_COMMIT_AI_STDOUT_PATH')

candidates = []
for path in (response_path, stdout_path):
    if path and os.path.exists(path):
        candidates.append(read_text(path))

fallback_candidates = []
message = ''
for blob in candidates:
    stripped = blob.strip()
    if not stripped:
        continue
    message = parse_json_blob(stripped)
    if message:
        break
    message = parse_json_lines(stripped)
    if message:
        break
    fallback = clean(stripped)
    if fallback:
        fallback_candidates.append(fallback)

if not message:
    for fallback in fallback_candidates:
        if fallback:
            message = fallback
            break

message = strip_meta_blocks(message)

if not message:
    for fallback in fallback_candidates:
        candidate = strip_meta_blocks(fallback)
        if candidate:
            message = candidate
            break

print(message.strip())
PY
        )
        MESSAGE_SOURCE="codex"
        [[ -z "$COMMIT_MESSAGE" ]] && CLI_STATUS=1
    fi
else
    echo "jj-commit-ai: 未知的 API 后端 '$API_BACKEND'" >&2
    exit 1
fi


# 质量检验：若输出为错误语言或含自述元话术，则触发回退
if (( CLI_STATUS == 0 )); then
  QUALITY_CHECK=$(LANG_PREF="$LANG_PREF" COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os, sys, re
msg = os.environ.get('COMMIT_MESSAGE','')
lang = os.environ.get('LANG_PREF','').lower()

def first_non_empty_line(s: str) -> str:
    for line in s.splitlines():
        t = line.strip()
        if t:
            return t
    return ''

subject = first_non_empty_line(msg)
low = subject.lower()

allow_english = bool(os.environ.get('JJ_COMMIT_AI_ALLOW_ENGLISH') or os.environ.get('GIT_COMMIT_AI_ALLOW_ENGLISH'))

if (not allow_english) and any(t in lang for t in ('zh','cn','中文')) and not re.search(r'[\u4e00-\u9fff]', msg):
    print('BAD'); sys.exit(0)

meta_tokens = (
    "i'm ", "i am ", "i will ", "i'll ", "we will ", "we'll ", "let's ",
    "i am carefully", "i'm carefully", "analyzing", "distill", "compose", "writing", "draft", "drafting"
)
if any(tok in low for tok in meta_tokens):
    print('BAD'); sys.exit(0)

print('OK')
PY
)
  if [[ "$QUALITY_CHECK" == "BAD" ]]; then
    QUALITY_REJECTION=1
    REJECTED_MESSAGE="$COMMIT_MESSAGE"
    CLI_STATUS=1
  fi
fi

if (( CLI_STATUS != 0 )); then
  if [[ -n "${QUALITY_REJECTION:-}" ]]; then
    echo "jj-commit-ai: 模型输出未通过质量检查，原始结果如下（已过滤）：" >&2
    echo "----------------------------------------" >&2
    printf '%s\n' "$REJECTED_MESSAGE" >&2
    echo "----------------------------------------" >&2
  fi
  [[ -n "$DEBUG" ]] && {
    if [[ "$API_BACKEND" == "codex" ]]; then
        echo "[jj-commit-ai] codex stdout (error path):" >&2
        cat "$TMP_STDOUT" >&2 || true
    fi
  }
  FALLBACK_MESSAGE=$(JJ_COMMIT_AI_DIFF_STAT="$DIFF_STAT" \
    JJ_COMMIT_AI_DIFF_OUTPUT="$DIFF_OUTPUT" \
    JJ_COMMIT_AI_LANG="$LANG_PREF" \
    JJ_COMMIT_AI_SUBJECT_STYLE="$SUBJECT_STYLE" \
    python3 - <<'PY'
import os
import re
import sys

stat = os.environ.get('JJ_COMMIT_AI_DIFF_STAT', '')
diff = os.environ.get('JJ_COMMIT_AI_DIFF_OUTPUT', '')
lang = os.environ.get('JJ_COMMIT_AI_LANG', '').lower()
style = os.environ.get('JJ_COMMIT_AI_SUBJECT_STYLE', '')

if not stat.strip() and not diff.strip():
    sys.exit(0)

locale = 'zh'
lang_hint = lang.strip()
if lang_hint and not any(token in lang_hint for token in ('zh', 'cn', 'chinese', '中文')):
    locale = 'en'

diff_blocks = []
current = None
for raw in diff.splitlines():
    if raw.startswith('diff --git '):
        if current:
            diff_blocks.append(current)
        parts = raw.split()
        a_path = parts[2][2:] if len(parts) >= 3 else ''
        b_path = parts[3][2:] if len(parts) >= 4 else ''
        current = {
            'a': a_path,
            'b': b_path,
            'lines': []
        }
    if current is None:
        continue
    current['lines'].append(raw)
if current:
    diff_blocks.append(current)

if not diff_blocks:
    for raw in stat.splitlines():
        raw = raw.strip()
        if '|' not in raw:
            continue
        path = raw.split('|', 1)[0].strip()
        if path:
            diff_blocks.append({'a': path, 'b': path, 'lines': [], 'type': 'modify'})
    if not diff_blocks:
        sys.exit(0)

def detect_kind(block):
    lines = block.get('lines', [])
    rename_from = None
    rename_to = None
    for line in lines:
        if line.startswith('rename from '):
            rename_from = line.split('rename from ', 1)[1].strip()
        elif line.startswith('rename to '):
            rename_to = line.split('rename to ', 1)[1].strip()
    if rename_from or rename_to:
        block['rename_from'] = rename_from or block.get('a')
        block['rename_to'] = rename_to or block.get('b')
        return 'rename'
    for line in lines:
        if line.startswith('new file mode'):
            return 'add'
        if line.startswith('deleted file mode'):
            return 'delete'
    return 'modify'

for block in diff_blocks:
    block['type'] = block.get('type') or detect_kind(block)

stat_counts = {}
for raw in stat.splitlines():
    if '|' not in raw:
        continue
    path, rest = raw.split('|', 1)
    key = path.strip()
    if not key:
        continue
    metrics = rest.strip()
    plus = metrics.count('+')
    minus = metrics.count('-')
    match = re.search(r'(\d+)', metrics)
    total = int(match.group(1)) if match else 0
    stat_counts[key] = {'plus': plus, 'minus': minus, 'total': total}

def shorten(path):
    if not path:
        return path
    return path if len(path) <= 40 else path.split('/')[-1]

def wrap_subject(text, style_name):
    if style_name == 'brackets':
        return f'[{text}]'
    if style_name == 'cn-brackets':
        return f'【{text}】'
    return text

labels = {
    'zh': {
        'add_one': '新增 {item}',
        'delete_one': '移除 {item}',
        'rename_one': '重命名 {src} 到 {dst}',
        'modify_one': '调整 {item}',
        'add_many': '新增多个文件',
        'delete_many': '移除多个文件',
        'modify_many': '批量调整文件',
        'mixed': '同步多项改动',
        'bullet_add': '新增 {item}',
        'bullet_delete': '删除 {item}',
        'bullet_modify': '更新 {item}',
        'bullet_rename': '重命名 {src} → {dst}'
    },
    'en': {
        'add_one': 'Add {item}',
        'delete_one': 'Remove {item}',
        'rename_one': 'Rename {src} to {dst}',
        'modify_one': 'Update {item}',
        'add_many': 'Add multiple files',
        'delete_many': 'Remove multiple files',
        'modify_many': 'Update multiple files',
        'mixed': 'Synchronize changes',
        'bullet_add': 'Add {item}',
        'bullet_delete': 'Remove {item}',
        'bullet_modify': 'Update {item}',
        'bullet_rename': 'Rename {src} → {dst}'
    }
}

chosen_labels = labels.get(locale, labels['en'])

def subject_for(blocks):
    total = len(blocks)
    if total == 0:
        return ''
    if total == 1:
        block = blocks[0]
        path = block.get('rename_to') or block.get('b') or block.get('a') or '文件'
        item = shorten(path) or '文件'
        kind = block.get('type', 'modify')
        if kind == 'add':
            return chosen_labels['add_one'].format(item=item)
        if kind == 'delete':
            return chosen_labels['delete_one'].format(item=item)
        if kind == 'rename':
            src = shorten(block.get('rename_from') or block.get('a') or '旧文件')
            dst = shorten(block.get('rename_to') or block.get('b') or '新文件')
            return chosen_labels['rename_one'].format(src=src, dst=dst)
        return chosen_labels['modify_one'].format(item=item)
    counts = {'add': 0, 'delete': 0, 'rename': 0, 'modify': 0}
    for block in blocks:
        counts[block.get('type', 'modify')] = counts.get(block.get('type', 'modify'), 0) + 1
    if counts['add'] == total:
        return chosen_labels['add_many']
    if counts['delete'] == total:
        return chosen_labels['delete_many']
    if counts['modify'] == total:
        return chosen_labels['modify_many']
    return chosen_labels['mixed']

def bullet_for(block):
    kind = block.get('type', 'modify')
    if kind == 'rename':
        src = shorten(block.get('rename_from') or block.get('a') or '')
        dst = shorten(block.get('rename_to') or block.get('b') or '')
        base = chosen_labels['bullet_rename'].format(src=src or '旧文件', dst=dst or '新文件')
        key = block.get('rename_to') or block.get('b') or block.get('a')
    else:
        path = shorten(block.get('b') or block.get('a') or '') or '文件'
        if kind == 'add':
            base = chosen_labels['bullet_add'].format(item=path)
        elif kind == 'delete':
            base = chosen_labels['bullet_delete'].format(item=path)
        else:
            base = chosen_labels['bullet_modify'].format(item=path)
        key = block.get('b') or block.get('a')
    stats = stat_counts.get(key)
    if not stats and '/' in key:
        stats = stat_counts.get(key.split('/', 1)[1])
    if stats:
        parts = []
        plus = stats.get('plus', 0)
        minus = stats.get('minus', 0)
        if plus:
            parts.append(f"+{plus}")
        if minus:
            parts.append(f"-{minus}")
        if not parts and stats.get('total'):
            parts.append(str(stats['total']))
        if parts:
            base += f"（{'/'.join(parts)}）"
    return base

subject_core = subject_for(diff_blocks)
subject_core = subject_core.strip()
if not subject_core:
    sys.exit(0)

subject = wrap_subject(subject_core, style)
if len(subject) > 72:
    subject = subject[:71] + '…'

bullets = [bullet_for(block).strip() for block in diff_blocks[:5]]
bullets = [b for b in bullets if b]

output_lines = [subject]
if bullets:
    output_lines.append('')
    output_lines.extend(f"- {line}" for line in bullets)

print('\n'.join(output_lines).strip())
PY
  )
  if [[ -n "$FALLBACK_MESSAGE" ]]; then
    USING_FALLBACK=1
    COMMIT_MESSAGE="$FALLBACK_MESSAGE"
    if [[ "$API_BACKEND" == "gemini" ]]; then
        echo "jj-commit-ai: Gemini API 调用失败 (exit $CLI_STATUS)，已回退到本地摘要" >&2
    else
        echo "jj-commit-ai: $CLI_COMMAND exec 失败 (exit $CLI_STATUS)，已回退到本地摘要" >&2
    fi
    MESSAGE_SOURCE="fallback"
  else
    if [[ "$API_BACKEND" == "gemini" ]]; then
        echo "jj-commit-ai: Gemini API 调用失败 (exit $CLI_STATUS)" >&2
    else
        echo "jj-commit-ai: $CLI_COMMAND exec 失败 (exit $CLI_STATUS)" >&2
        cat "$TMP_STDOUT" >&2 || true
    fi
    exit "$CLI_STATUS"
  fi
fi

if [[ -z "$COMMIT_MESSAGE" ]]; then
  echo "jj-commit-ai: 模型未返回内容" >&2
  if [[ -z "$DEBUG" ]]; then
    echo "(可设置 JJ_COMMIT_AI_DEBUG=1 查看原始输出)" >&2
  fi
  exit 1
fi

if [[ -z "$MESSAGE_SOURCE" ]]; then
  if (( USING_FALLBACK )); then
    MESSAGE_SOURCE="fallback"
  else
    MESSAGE_SOURCE="$API_BACKEND"
  fi
fi

SOURCE_LABEL="生成的提交信息："
case "$MESSAGE_SOURCE" in
  gemini)
    SOURCE_LABEL="Gemini API 生成的提交信息："
    ;;
  codex)
    SOURCE_LABEL="Codex API 生成的提交信息："
    ;;
  fallback)
    SOURCE_LABEL="本地摘要生成的提交信息："
    ;;
esac

## 统一第一行括号风格：整行标题包裹在指定括号内
COMMIT_MESSAGE=$(SUBJECT_STYLE="$SUBJECT_STYLE" COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os
msg = os.environ.get('COMMIT_MESSAGE','')
style = os.environ.get('SUBJECT_STYLE','')
lines = msg.splitlines()

def wrap_full(subject: str, left: str, right: str) -> str:
    s = subject.strip()
    if s.startswith(left):
        s = s[len(left):]
    if s.endswith(right):
        s = s[:-len(right)]
    if len(s) > 72:
        s = s[:71] + '…'
    return f"{left}{s.strip()}{right}"

if lines:
    i = 0
    while i < len(lines) and not lines[i].strip():
        i += 1
    if i < len(lines):
        subj = lines[i]
        if style == 'cn-brackets':
            lines[i] = wrap_full(subj, '【', '】')
        elif style == 'brackets':
            lines[i] = wrap_full(subj, '[', ']')

print('\n'.join(lines))
PY
)

# 限制要点数量并做轻量规范（最多 3 条，适度截断）
COMMIT_MESSAGE=$(COMMIT_MESSAGE="$COMMIT_MESSAGE" python3 - <<'PY'
import os
msg = os.environ.get('COMMIT_MESSAGE','')
lines = msg.splitlines()

def normalize_bullets(ls):
    i = 0
    while i < len(ls) and not ls[i].strip():
        i += 1
    if i >= len(ls):
        return ls
    j = i + 1
    if j < len(ls) and ls[j].strip():
        ls.insert(j, '')
    k = j + 1
    bullets = []
    while k < len(ls):
        s = ls[k].lstrip()
        if s.startswith(('- ', '* ', '• ', '· ')):
            bullets.append((k, ls[k]))
        k += 1
    if not bullets:
        return ls
    keep = set(idx for idx, _ in bullets[:3])
    for idx, text in bullets:
        if idx in keep:
            t = text.rstrip().rstrip('。；;,.，')
            if len(t) > 80:
                t = t[:79] + '…'
            ls[idx] = t
        else:
            ls[idx] = None
    return [x for x in ls if x is not None]

print('\n'.join(normalize_bullets(lines)))
PY
)

[[ -n "$DEBUG" ]] && {
  echo "[jj-commit-ai] 提交信息如下:" >&2
  printf '%s\n' "$COMMIT_MESSAGE" >&2
}

MSG_FILE=$(mktemp "${TMPDIR:-/tmp}/jj-commit-msg-XXXXXX")
printf '%s\n' "$COMMIT_MESSAGE" >"$MSG_FILE"

if (( PREVIEW_ONLY )); then
  echo "$SOURCE_LABEL" >&2
  echo "----------------------------------------" >&2
  cat "$MSG_FILE"
  echo "----------------------------------------" >&2
  exit 0
fi

echo "$SOURCE_LABEL" >&2
echo "----------------------------------------" >&2
cat "$MSG_FILE" >&2
echo "----------------------------------------" >&2

run_commit() {
  local commit_msg
  commit_msg=$(cat "$MSG_FILE")
  if (( ${#JJ_ARGS[@]} )); then
    jj commit --message "$commit_msg" ${JJ_ARGS[@]}
  else
    jj commit --message "$commit_msg"
  fi
}

if (( AUTO_COMMIT )); then
  run_commit
  exit 0
fi

if (( ASSUME_YES )); then
  run_commit
  exit 0
fi

read -r -p "是否使用该提交信息? [y/N] " REPLY
case "$REPLY" in
  [yY][eE][sS]|[yY])
    run_commit
    ;; 
  *)
    echo "jj-commit-ai: 已放弃提交（上方已显示生成的消息）" >&2
    ;; 
esac
