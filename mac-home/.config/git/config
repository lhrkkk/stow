[user]
        name = lu haorui
        email = airhenry@gmail.com

[core]
        editor = hx
        pager = delta
        quotepath = false
        autocrlf = false

[commit]
        template = /Users/lhr/.stCommitMsg

[filter "lfs"]
        required = true
        clean = git-lfs clean -- %f
        smudge = git-lfs smudge -- %f
        process = git-lfs filter-process

[color]
        ui = auto
[color "branch"]
        current = yellow reverse
        local = yellow
        remote = green
[color "diff"]
        meta = yellow bold
        frag = magenta bold
        old = red
        new = green

[init]
        defaultBranch = main

[diff]
        colorMoved = default
        algorithm = patience
        mnemonicprefix = true
        tool = araxis
[alias]
    ad  = difftool --tool=araxis --dir-diff
    ads = difftool --tool=araxis --dir-diff --staged
[difftool]
    prompt = false

[merge]
        summary = true
        verbosity = 1
        conflictStyle = zdiff3
        tool = smerge

[mergetool]
        prompt = false
[mergetool "smerge"]
        cmd = smerge mergetool "$BASE" "$LOCAL" "$REMOTE" -o "$MERGED"
        trustExitCode = true
        keepBackup = false
# 仅保留配置，不设为默认；如需切换到 mvimdiff：把 [merge].tool 改成 mvimdiff
[mergetool "mvimdiff"]
        cmd = "mvim -c 'Gdiff' $MERGED"
        keepbackup = false

[rebase]
        autosquash = true
        updateRefs = true

[fetch]
        prune = true
        pruneTags = true

[push]
        default = current
        autoSetupRemote = true

[interactive]
        diffFilter = delta --color-only

[delta]
        navigate = true
        line-numbers = true
        # 可按需添加: side-by-side = true, syntax-theme = OneHalfDark 等

[pretty]
        jj = format:%C(yellow)%h%Creset %C(auto)%d%Creset %s %C(blue)<%an>%Creset %C(cyan)%cr%Creset

[format]
        pretty = format:%C(blue)%ad%Creset %C(yellow)%h%C(green)%d%Creset %C(blue)%s %C(magenta) [%an]%Creset

[rerere]
        enabled = true

[advice]
        statusHints = false

[apply]
        whitespace = nowarn

[branch]
        autosetupmerge = true

[include]
        path = .gitconfig.user

[alias]
        # ---- Git Town（保留） ----
        append = town append
        hack = town hack
        kill = town kill
        new-pull-request = town new-pull-request
        prepend = town prepend
        prune-branches = town prune-branches
        rename-branch = town rename-branch
        repo = town repo
        ship = town ship
        sync = town sync


        # ---- 初始化/克隆 ----
        init = "!git init && git symbolic-ref HEAD refs/heads/main"
        cl   = clone
        clg  = "!f(){ git clone https://github.com/$1; }; f"
        clgp = "!f(){ git clone git@github.com:$1; }; f"
        clgu = "!f(){ u=$(git config user.username); git clone git@github.com:${u}/$1; }; f"

        # ---- 常用增强 ----
        s  = status
        st = status
        stat = status
        sf = "!f(){ git status --short --branch; echo; git diff --stat; }; f"

        # log
        l  = log --graph --date=short
        lg = log --graph --decorate --abbrev-commit --date=relative --pretty=jj --all
        changes = log --pretty=format:\"%h %cr %cn %Cgreen%s%Creset\" --name-status
        short = log --pretty=format:\"%h %cr %cn %Cgreen%s%Creset\"
        simple = log --pretty=format:\" * %s\"
        shortnocolor = log --pretty=format:\"%h %cr %cn %s\"
        filelog = log -u
        default = "!f(){ echo; git sf; echo; git -c pager.log=false lg -n 20; }; f"

        # add / stash
        a = add
        aa = !git add .
        chunkyadd = add --patch
        ss = stash
        sl = stash list
        sa = stash apply
        sd = stash drop
        snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"
        snapshots = !git stash list --grep snapshot

        # branch / checkout
        #b = branch -v
	b = "!f(){ usage(){ echo \"用法: git b [<branch>] | git b -d|-D <branch> | git b --rm-remote <branch>\"; }; if [ $# -eq 0 ]; then git branch -vv; return; fi; case \"$1\" in -d|-D) op=\"$1\"; shift; [ $# -ge 1 ] || { usage; return 1; }; git branch \"$op\" -- \"$1\"; ;; --rm-remote) shift; [ $# -ge 1 ] || { usage; return 1; }; git push origin --delete \"$1\"; ;; *) b=\"$1\"; git switch \"$b\" 2>/dev/null || git switch -c \"$b\" --track \"origin/$b\" 2>/dev/null || git switch -c \"$b\"; ;; esac; }; f \"$@\""
        co = checkout
        nb = checkout -b
        recent-branches = !git for-each-ref --count=15 --sort=-committerdate refs/heads/ --format='%(refname:short)'

        # commit
        c = commit -m
        cm = commit -m
        ca = commit -am
        cc = "!f(){ git-commit-ai --api gemini; }; f"

        cam ="!f(){ git a . && git cm $1;}; f"
        ci = commit
        amend = commit --amend
        ammend = commit --amend

        # cherry-pick
        cp = cherry-pick -x

        # diff / show
        d  = diff
        dc = diff --cached
        last = diff HEAD^
        dr = "!f(){ git diff ${1:-HEAD}; }; f"
        w  = show
        ws = show --stat

        # remote / push / pull
        r = remote -v
        ps = push
        psa = push --all
        psd = "!f(){ git push origin :$1; }; f"
        psb = "!f(){ git push -u origin ${1:-$(git branch --show-current)}; }; f"
        pscb = "!f(){ b=${1:-$(git rev-parse --abbrev-ref HEAD)}; git push -u origin \"$b\"; }; f"
        pl = pull
        fo = fetch --all --prune
        f  = "!git fo && git rbt"

        # rebase
        rb  = rebase --rebase-merges --autostash
        rbt = rebase --rebase-merges --autostash origin/main
        rbr = rebase -i --rebase-merges --autostash
        rc = rebase --continue
        rs = rebase --skip

        # PR（GitHub CLI）
        pro = "!gh pr create --head $(git rev-parse --abbrev-ref HEAD)"
        pr  = "!f(){ b=${1:-$(git rev-parse --abbrev-ref HEAD)}; git pscb \"$b\"; gh pr create --head \"$b\"; }; f"

        # worktree / reflog / blame
        wl = worktree list
        wa = "!f(){ b=${1:?branch}; p=${2:-.jj/$b}; git branch -f \"$b\" HEAD; git worktree add \"$p\" \"$b\"; }; f"
        wf = "!f(){ git worktree remove \"$1\"; }; f"

        wa1 = "!f(){ git worktree add .jj/git-1;}; f"
        wa2 = "!f(){ git worktree add .jj/git-2;}; f"
        wa3 = "!f(){ git worktree add .jj/git-3;}; f"

	wo1 = "!f(){ root=$(git rev-parse --show-toplevel 2>/dev/null) || { echo >&2 'Not inside a Git repository'; return 1; }; dir=\"$root/.jj/git-1\"; [ -d \"$dir\" ] || { echo >&2 'Workspace not found:' \"$dir\"; return 1; }; export WO_RETURN_DIR=\"$root\"; cd -- \"$dir\" || return 1; if [ \"$#\" -eq 0 ]; then exec \"${SHELL:-/bin/sh}\" -l; else \"$@\"; fi; }; f"
	wo2 = "!f(){ root=$(git rev-parse --show-toplevel 2>/dev/null) || { echo >&2 'Not inside a Git repository'; return 1; }; dir=\"$root/.jj/git-2\"; [ -d \"$dir\" ] || { echo >&2 'Workspace not found:' \"$dir\"; return 1; }; export WO_RETURN_DIR=\"$root\"; cd -- \"$dir\" || return 1; if [ \"$#\" -eq 0 ]; then exec \"${SHELL:-/bin/sh}\" -l; else \"$@\"; fi; }; f"
	wo3 = "!f(){ root=$(git rev-parse --show-toplevel 2>/dev/null) || { echo >&2 'Not inside a Git repository'; return 1; }; dir=\"$root/.jj/git-3\"; [ -d \"$dir\" ] || { echo >&2 'Workspace not found:' \"$dir\"; return 1; }; export WO_RETURN_DIR=\"$root\"; cd -- \"$dir\" || return 1; if [ \"$#\" -eq 0 ]; then exec \"${SHELL:-/bin/sh}\" -l; else \"$@\"; fi; }; f"

	rbi = "!f(){ ws=\"$1\"; root=$(git rev-parse --show-toplevel 2>/dev/null) || return 1; case \"$ws\" in wo1) sub=git-1;; wo2) sub=git-2;; wo3) sub=git-3;; *) return 1;; esac; dir=\"$root/.jj/$sub\"; [ -d \"$dir\" ] || return 2; gd=$(git -C \"$dir\" rev-parse --git-dir 2>/dev/null) || return 2; [ -d \"$gd/rebase-merge\" ] || [ -d \"$gd/rebase-apply\" ]; }; f"
        wsl = "!f(){ for n in 1 2 3; do ws=wo$n; if git \"$ws\" sh -lc : >/dev/null 2>&1; then if git rbi \"$ws\"; then echo \"[wsl] ws$n: REBASE\"; else echo \"[wsl] ws$n: clean\"; fi; else echo \"[wsl] ws$n: skip\"; fi; done; }; f"

        # 同步所有节点，检测是否存在冲突并立刻停下来处理
	ws1 = "!f(){ git rbi wo1; st=$?; if [ $st -eq 0 ]; then git wo1 git rebase --continue && git wo1 git rebase main; elif [ $st -eq 2 ]; then echo \"[ws1] skip: missing workspace\"; return 0; else git wo1 git rebase main; fi; }; f"
	ws2 = "!f(){ git rbi wo2; st=$?; if [ $st -eq 0 ]; then git wo2 git rebase --continue && git wo2 git rebase main; elif [ $st -eq 2 ]; then echo \"[ws2] skip: missing workspace\"; return 0; else git wo2 git rebase main; fi; }; f"
	ws3 = "!f(){ git rbi wo3; st=$?; if [ $st -eq 0 ]; then git wo3 git rebase --continue && git wo3 git rebase main; elif [ $st -eq 2 ]; then echo \"[ws3] skip: missing workspace\"; return 0; else git wo3 git rebase main; fi; }; f"
	wsa = "!f(){ echo \"[wsa] ws1\"; git ws1; echo \"[wsa] ws2\"; git ws2; echo \"[wsa] ws3\"; git ws3; }; f"

        # 合并所有节点
	wm1 = "!f(){ echo \"[wm1] ws1 -> rebase git-1\"; root=$(git rev-parse --show-toplevel 2>/dev/null) || return 1; dir=\"$root/.jj/git-1\"; if [ ! -d \"$dir\" ]; then echo \"[wm1] skip: missing ws1\"; return 0; fi; git ws1 && git rebase git-1; }; f"
	wm2 = "!f(){ echo \"[wm2] ws2 -> rebase git-2\"; root=$(git rev-parse --show-toplevel 2>/dev/null) || return 1; dir=\"$root/.jj/git-2\"; if [ ! -d \"$dir\" ]; then echo \"[wm2] skip: missing ws2\"; return 0; fi; git ws2 && git rebase git-2; }; f"
	wm3 = "!f(){ echo \"[wm3] ws3 -> rebase git-3\"; root=$(git rev-parse --show-toplevel 2>/dev/null) || return 1; dir=\"$root/.jj/git-3\"; if [ ! -d \"$dir\" ]; then echo \"[wm3] skip: missing ws3\"; return 0; fi; git ws3 && git rebase git-3; }; f"
	wma = "!f(){ git wm1 && git wm2 && git wm3; }; f"

	wms1 = "!f(){ git wm1 && git wsa; }; f"
	wms2 = "!f(){ git wm2 && git wsa; }; f"
	wms3 = "!f(){ git wm3 && git wsa; }; f"

        # 通常运行这一条就行，合并所有提交。分支上做好了没问题才提交，这样就可以合并所有。
        #wmsa ="!f(){ git wms1 && git wms2 && git wms3;}; f"
	wmsa = "!f(){ git wm1 && git wm2 && git wm3 && git wsa; }; f"

#wm1 = ["util", "exec", "--", "bash", "-lc","jj new main one@ && jj bs main"]
#ws1 = ["util", "exec", "--", "bash", "-lc","jj wo1 jj-sync && jj wo1 jj bs one"]

        ol = reflog
        fn = blame
        fnr = "!f(){ git blame -L ${2:?line-range} -- $1; }; f"

        # svn（如无需要可删）
        svnr = svn rebase
        svnd = svn dcommit
        svnl = svn log --oneline --show-commit

        # 其他
        contributors = shortlog --summary --numbered --email
        mt = mergetool
	wo = "!f(){ if [ -n \"${WO_RETURN_DIR:-}\" ]; then root=\"$WO_RETURN_DIR\"; else root=$(git rev-parse --show-toplevel 2>/dev/null) || { echo >&2 'Not inside a Git repository'; return 1; }; fi; [ -d \"$root\" ] || { echo >&2 'Root not found:' \"$root\"; return 1; }; cd -- \"$root\" || return 1; if [ \"$#\" -eq 0 ]; then exec \"${SHELL:-/bin/sh}\" -l; else \"$@\"; fi; }; f"

