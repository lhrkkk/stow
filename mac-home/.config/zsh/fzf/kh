#compdef kh
# kh — 交互式删除 zsh 历史（基于 fzf）
# - Tab 多选，Enter 确认
# - 显示风格近似 fhistory：第1列为事件范围 start:end，其余为合并的一行命令文本
# - 删除按文件行号范围进行（支持多行命令整体删除），随后写回 $HISTFILE 并重新加载会话
# 依赖: fzf, zsh 5+

emulate -L zsh -o extendedglob -o noaliases
setopt local_options no_errexit pipefail

# 尝试弹出任何残留的历史上下文
for _i in {1..5}; do
  fc -P 2>/dev/null || break
done

# 帮助
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
  cat <<'KH_HELP'
kh - 交互式删除 zsh 历史（基于 fzf）
用法：
  kh               打开历史选择器（Tab 多选，Enter 确认）
环境变量：
  KH_LIMIT=0       限制加载的历史条数（按“事件”计，0 表示不限制）
  KH_BACKUP=1      删除前备份 HISTFILE（默认 1）
  KH_DEDUP=0       是否按命令内容去重显示（默认 0，1 表示去重）
说明：
  - 列表基于 HISTFILE 构造，第一列为事件的文件行号范围 start:end；
    展示文本将同一事件内多行以“⏎”连接到一行，搜索仅匹配命令文本（忽略范围列）。
  - 删除按所选 start:end 范围精确过滤原文件（多行命令整体删除），随后写回并重新加载会话历史。
  - 为避免干扰，fzf 调用时不继承 FZF_DEFAULT_OPTS。
KH_HELP
  return 0
fi

if ! command -v fzf >/dev/null 2>&1; then
  print -u2 -- "kh: 需要 fzf，请先安装"
  return 1
fi

local histfile limit
histfile="${HISTFILE:-$HOME/.zsh_history}"
limit="${KH_LIMIT:-0}"

# 将当前会话内存历史写回，保证文件最新
builtin fc -W "$histfile" 2>/dev/null || true

# 读取 HISTFILE，按扩展历史分组为事件，输出：start:end 合并为一行后的解码文本（最新在前）
local list
if [[ -f "$histfile" ]]; then
  list=$(LC_ALL=C awk '
      BEGIN { OFS=" " }
      function flush(){
        if (inrec) {
          merged=rec_text
          gsub(/\r/, "", merged)
          gsub(/\n/, " ⏎ ", merged)
          print rec_start ":" rec_end, merged
          inrec=0; rec_text=""
        }
      }
      {
        raw=$0
        is_hdr = match(raw, /^: [0-9]+:[0-9]+;/)
        if (is_hdr) has_ext=1
        if (has_ext) {
          if (is_hdr) {
            flush()
            rec_start=NR; rec_end=NR
            rec_text=raw
            sub(/^: [0-9]+:[0-9]+;/, "", rec_text)
            inrec=1
          } else {
            if (!inrec) {
              rec_start=NR; rec_end=NR; rec_text=raw; inrec=1
            } else {
              rec_end=NR
              rec_text = rec_text "\n" raw
            }
          }
        } else {
          # 非扩展历史：使用反斜杠续行启发式进行合并
          if (!inrec) {
            rec_start=NR; rec_end=NR; rec_text=raw; inrec=1
          } else {
            rec_end=NR
            rec_text = rec_text "\n" raw
          }
          # 若当前行不以反斜杠结尾（可有空白），认为事件结束
          if (raw !~ /\\[ \t]*$/) {
            flush()
          }
        }
      }
      END { flush() }
    ' "$histfile" |
    perl -pe 's/\x83(.)/chr(ord($1)^32)/eg' |
    tail -r)
  if [[ -n "$list" && "$limit" != 0 ]]; then
    list=$(printf "%s\n" "$list" | head -n "$limit")
  fi
  if [[ -n "$list" && "${KH_DEDUP:-0}" != "0" ]]; then
    list=$(printf "%s\n" "$list" | LC_ALL=C sort -k 2 -u | LC_ALL=C sort -r)
  fi
fi

if [[ -z "$list" ]]; then
  print -- "无历史记录"
  return 0
fi

local header sel
header="选择要删除的历史（Tab 多选，Enter 确认；Ctrl-C 取消）"
sel=$(printf "%s\n" "$list" | \
  # FZF_DEFAULT_OPTS=""
  fzf --multi -n2..,.. --tiebreak=index \
    --height=80% --layout=reverse --info=inline \
    --prompt='删除历史> ' --header="$header" \
    --bind='ctrl-a:toggle-all,tab:toggle+down,shift-tab:toggle+up' \
    --preview 'se={1}; s=${se%%:*}; e=${se##*:}; if [ -n "$s" ] && [ -n "$e" ]; then LC_ALL=C awk -v s="$s" -v e="$e" "NR>=s && NR<=e {print}" '"$histfile"' | perl -pe '\''s/\x83(.)/chr(ord($1)^32)/eg'\''; fi' \
    --preview-window=down,7,wrap) || return 0

# 选中的“start:end”范围列表
local -a ranges
ranges=(${(f)"$(printf "%s\n" "$sel" | awk '{print $1}')"})
local n=${#ranges}
if (( n == 0 )); then
  print -- "未选择，已取消"
  return 0
fi

# 展开为需删除的具体行号集合
local -A __kh_sel
local pair start end i
for pair in $ranges; do
  start=${pair%%:*}
  end=${pair##*:}
  if [[ -z $start || -z $end ]]; then
    continue
  fi
  if (( end < start )); then
    local tmp=$start; start=$end; end=$tmp
  fi
  for (( i = start; i <= end; i++ )); do
    __kh_sel[$i]=1
  done
done

# 可选备份
if [[ "${KH_BACKUP:-1}" != "0" && -f "$histfile" ]]; then
  local __bak="${histfile}.$(date +%Y%m%d%H%M%S).bak"
  cp -p "$histfile" "$__bak" 2>/dev/null || cp "$histfile" "$__bak" 2>/dev/null || true
fi

# 过滤原文件，写入临时文件
local __tmp
__tmp=$(mktemp "${TMPDIR:-/tmp}/kh.XXXXXX") || { print -u2 -- "kh: 无法创建临时文件"; return 1; }

local ln idx=0 kept=0
while IFS='' read -r ln; do
  (( idx++ ))
  if [[ -z ${__kh_sel[$idx]} ]]; then
    print -r -- "$ln" >>| "$__tmp"
    (( kept++ ))
  fi
done < "$histfile"

# 替换原文件
if [[ -f "$__tmp" ]]; then
  mv -f "$__tmp" "$histfile"
else
  rm -f "$__tmp" 2>/dev/null || true
  print -u2 -- "kh: 过滤失败"
  return 1
fi

# 重新加载会话历史，避免重复与不同步
local __orig_histsize=$HISTSIZE
HISTSIZE=0
HISTSIZE=$__orig_histsize
builtin fc -R "$histfile" 2>/dev/null || true

print -- "已删除 ${n} 条记录，并写回：$histfile（保留 ${kept} 行）"
return 0

